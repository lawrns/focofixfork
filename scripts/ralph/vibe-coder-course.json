{
  "workspace_id": "",
  "slug": "de-developer-a-vibe-coder",
  "title": "De Developer a Vibe Coder",
  "description": "Transforma tu manera de desarrollar software con IA. Domina los patrones de orquestacion, multi-agent systems y prompt engineering que definen el siguiente nivel de desarrollo.",
  "duration_minutes": 240,
  "is_published": true,
  "sort_order": 1,
  "sections": [
    {
      "title": "Modulo 0: Orientacion - Reseta tus expectativas",
      "content_type": "markdown",
      "content": "# Modulo 0: Orientacion - Reseta tus expectativas\n\n## ¿Qué es Vibe Coding?\n\n**Vibe coding no es lo que crees.**\n\nLa mayoría de desarrolladores escuchan \"vibe coding\" y piensan en:\n- \"Pedirle a ChatGPT que escriba código\"\n- \"Copiar y pegar de StackOverflow con IA\"\n- \"Perder el control sobre lo que produces\"\n\n**Eso NO es vibe coding.**\n\nVibe coding es una disciplina de **orquestación de inteligencia artificial para magnificar capacidades humanas**, no para reemplazarlas. Es la diferencia entre:\n\n❌ **Mal enfoque**: \"IA es mi empleado junior que hace el trabajo sucio\"\n\n✅ **Vibe coding**: \"IA es mi socio de pensamiento que explora posibilidades que yo dirijo\"\n\n## La Regla de Oro\n\n### **\"IA explora, humanos deciden\"**\n\nEsta es la fundación de todo en Fyves. Significa:\n\n| Responsabilidad | IA | Humanos |\n|----------------|-----|---------|\n| **Explorar** opciones | ✅ | ❌ |\n| **Generar** alternativas | ✅ | ❌ |\n| **Ejecutar** tareas definidas | ✅ | ❌ |\n| **Decidir** qué construir | ❌ | ✅ |\n| **Validar** calidad | ❌ | ✅ |\n| **Aprobar** cambios | ❌ | ✅ |\n\n**El error más común**: Dejar que la IA decida QUÉ construir sin tu dirección explícita.\n\n**El secreto**: La IA es excelente en el \"cómo\", terrible en el \"qué\".\n\n## Las 4 Reglas Fundamentales de Desarrollo Fyves\n\n### 1. IA explora, humanos deciden\nYa cubierto arriba. Es la base de todo.\n\n### 2. Código antes de prompts\n\n**Nunca escribas un prompt sin primero escribir el código que deseas.**\n\n❌ **Anti-patrón**:\n```\nPrompt: \"Ayúdame a crear un sistema de autenticación\"\n```\n\n✅ **Vibe coding**:\n```typescript\n// Primero, escribe lo que quieres:\ninterface AuthSystem {\n  login(email: string, password: string): Promise<Session>\n  logout(sessionId: string): Promise<void>\n  verify(sessionId: string): Promise<User | null>\n}\n\n// Luego, pide a la IA que lo implemente:\nPrompt: \"Implementa esta interfaz de AuthSystem usando Supabase...\"\n```\n\n**Por qué funciona**:\n- Tienes claridad sobre el resultado deseado\n- La IA tiene especificaciones precisas\n- Puedes validar que el código cumple tu intención\n\n### 3. Compuestos, no monolitos\n\nLos sistemas de vibe coding son **compuestos de componentes pequeños y enfocados**, no monolitos gigantes.\n\n**Características de componentes vibe-ready**:\n\n| ✅ Componente Vibe | ❌ Anti-vibe |\n|--------------------|-------------|\n| Una responsabilidad clara | Múltiples responsabilidades |\n| Menos de 200 líneas | Cualquier tamaño |\n| Interfaces explícitas | Código implícito |\n| Fácil de testear | Difícil de probar |\n| Fácil de explicar | Requiere largo explicación |\n\n**La regla del pulgar**: Si no puedes explicar qué hace un componente en 15 segundos, es demasiado complejo.\n\n### 4. Determinismo > elegancia\n\nEn vibe coding, **el código que funciona siempre es mejor que el código elegante**.\n\n❌ **Elegancia sin determinismo**:\n```typescript\n// Muy elegante, pero ¿qué pasa si user.metadata es undefined?\nconst role = user.metadata?.roles?.[0]?.name ?? 'guest'\n```\n\n✅ **Determinismo primero**:\n```typescript\n// Menos elegante, pero siempre predecible\nconst role = (() => {\n  if (!user?.metadata) return 'guest'\n  if (!user.metadata.roles || user.metadata.roles.length === 0) return 'guest'\n  return user.metadata.roles[0].name\n})()\n```\n\n**Principio**: La IA puede generar código elegante. Los humanos debemos asegurar que sea **determinístico**.\n\n---\n\n## Ejercicio Rápido: Identifica el Enfoque\n\nLee estos escenarios y decide si siguen vibe coding o no:\n\n**Escenario 1**:\n> \"Le pedí a Claude que diseñara la arquitectura de mi proyecto y la implementó.\"\n\n❌ **NO es vibe coding** - La IA decidió QUÉ construir.\n\n**Escenario 2**:\n> \"Escribí las interfaces y casos de prueba, luego pedí a la IA que implementara los tests paso a paso.\"\n\n✅ **Sí es vibe coding** - Tú definiste QUÉ, la IA ejecutó CÓMO.\n\n**Escenario 3**:\n> \"Le di a la IA mi repositorio completo y le pedí que lo refactorizara.\"\n\n❌ **NO es vibe coding** - Sin dirección explícita, la IA decide qué cambiar.\n\n---\n\n## Checklist de Orientación\n\nAntes de continuar, verifica que entiendes:\n\n- [ ] La diferencia entre \"IA decide\" y \"IA explora\"\n- [ ] Por qué debes escribir código antes de prompts\n- [ ] Qué hace que un componente sea \"vibe-ready\"\n- [ ] Por qué el determinismo es más importante que la elegancia\n\n**¿Tienes dudas? Reviste este módulo antes de avanzar.** Estos conceptos son la fundación de todo lo que sigue.",
      "content_url": null,
      "sort_order": 0,
      "duration_minutes": 10
    },
    {
      "title": "Modulo 1: The Vibe Shift - Control vs Orquestacion",
      "content_type": "markdown",
      "content": "# Modulo 1: The Vibe Shift - Control vs Orquestacion\n\n## El Problema del Control\n\nLa mayoría de desarrolladores fuimos entrenados para **querer control total** sobre:\n- Cada línea de código\n- Cada decisión de arquitectura\n- Cada variable y función\n\nEsto funcionó durante décadas. Pero la IA cambió las reglas del juego.\n\n### El Loop de Ansiedad del Developer Tradicional\n\n```\n1. Quieres construir X\n2. Pasas 2 días planeando cada detalle\n3. Escribes código por 3 días\n4. Descubres que tu arquitectura no escala\n5. Vuelves al paso 1\n   \nResultado: 2 semanas perdidas en algo que podría haber tomado 2 horas\n```\n\n**¿Te suena familiar?**\n\n### La Trampa de Sobre-Planear\n\nSobre-planear mata velocidad porque:\n1. **La realidad siempre es diferente** que tus planes\n2. **No puedes predecir** todos los edge cases\n3. **La IA puede iterar 100x más rápido** que tu proceso de planificación\n\n**El secreto**: En lugar de planear exhaustivamente, **explora iterativamente con IA**.\n\n---\n\n## El Cambio a Orquestación\n\nVibe coding cambia la pregunta fundamental:\n\n| ❌ Pregunta Antigua | ✅ Nueva Pregunta |\n|-------------------|-----------------|\n| \"¿Cómo puedo escribir este código?\" | \"¿Cómo puedo ORQUESTAR que la IA escriba este código?\" |\n| \"¿Qué arquitectura es mejor?\" | \"¿Cómo puedo EXPLORAR arquitecturas con la IA?\" |\n| \"¿Cómo resuelvo este bug?\" | \"¿Cómo puedo dirigir a la IA para encontrar y resolver este bug?\" |\n\n### Orquestación no es Solo \"Pedir\"\n\n**Orquestación** tiene tres componentes:\n\n1. **Dirección**: Tú defines el QUÉ\n2. **Exploración**: La IA genera múltiples CÓMOs\n3. **Decisión**: Tú seleccionas el mejor camino\n\n```typescript\n// Ejemplo: Orquestación en acción\n\n// 1. DIRECCIÓN (Tú)\ninterface UserProfile {\n  id: string\n  email: string\n  preferences: UserPreferences\n  getRecommendations(): Promise<Recommendation[]>\n}\n\n// 2. EXPLORACIÓN (IA)\n// Genera 3 implementaciones diferentes:\n// - Opción A: Clase tradicional con métodos\n// - Opción B: Functional composition\n// - Opción C: Class-based pero con factories\n\n// 3. DECISIÓN (Tú)\n// Evalúas:\n// - Opción A: Fácil de entender, difícil de testear\n// - Opción B: Fácil de testear, curva de aprendizaje alta\n// - Opción C: Balanceado, pero más complejo\n// \n// Tú decides basado en tu contexto específico.\n```\n\n---\n\n## Exploración Paralela vs Pensamiento Lineal\n\n### Pensamiento Lineal (Desarrollador Tradicional)\n\n```\nPaso 1 → Paso 2 → Paso 3 → Paso 4\n ↓       ↓       ↓       ↓\n     (cada paso te bloquea el siguiente)\n```\n\n**Problema**: Si Paso 2 está mal, pierdes todo el trabajo en Paso 3 y 4.\n\n### Exploración Paralela (Vibe Coding)\n\n```\n                   ↓\n                  IA\n                  ↓\n        ┌──────┬──────┬──────┐\n        ↓      ↓      ↓      ↓\n    Opción 1 Opción 2 Opción 3 Opción 4\n        ↓      ↓      ↓      ↓\n     (evalúas todas en paralelo)\n```\n\n**Ventaja**: Ves 4 caminos diferentes antes de comprometerte con uno.\n\n### La Técnica del \"Council\"\n\nUn patrón poderoso de vibe coding es crear un \"consejo\" de agentes:\n\n```\nTú: \"Quiero implementar un sistema de caché distribuido\"\n\n     Agent.run(\n       name: \"Arquitecto Conservador\",\n       task: \"Diseña un sistema de caché Redis simple\"\n     )\n\n     Agent.run(\n       name: \"Arquitecto Innovador\",\n       task: \"Diseña un sistema de caché usando edge computing\"\n     )\n\n     Agent.run(\n       name: \"Arquitecto Pragmático\",\n       task: \"Diseña un sistema de caché usando Memcached\"\n     )\n\nTú: Evalúas las 3 propuestas y decides (o combinas lo mejor de cada una)\n```\n\n---\n\n## \"No Sé Todavía\" es un Estado Válido\n\nEn vibe coding, **\"no sé todavía\" es una respuesta legítima y productiva**.\n\n### El Síndrome del Falso Conocimiento\n\nLos desarrolladores tradicionales sienten presión de:\n- \"Tener que saber\" la solución antes de escribir código\n- \"Poder explicar\" cada decision arquitectónica\n- \"Justificar\" cada línea de código\n\n**Resultado**: Fingen saber cuando no saben. Esto conduce a malas decisiones.\n\n### El Enfoque Vibe Coding\n\n✅ **Admite ignorance**:\n```\n\"No sé cuál es la mejor arquitectura para esto. Voy a explorar opciones con IA.\"\n```\n\n✅ **Explora múltiples caminos**:\n```\n\"IA: Explora 3 arquitecturas diferentes para este problema y explíca pros y contras de cada una.\"\n```\n\n✅ **Decide después de explorar**:\n```\n\"Vistas las 3 opciones, elijo la arquitectura B porque...\"\n```\n\n---\n\n## Ejercicio: Reescribe un Plan Tradicional\n\n**Tu turno**: Transforma este plan tradicional en un \"agent swarm brief\".\n\n### Plan Tradicional (Anti-Vibe)\n\n```\nPROYECTO: Sistema de notificaciones\n\nPLAN:\n1. Diseñar esquema de base de datos\n2. Crear API REST\n3. Implementar WebSocket server\n4. Construir frontend\n5. Testing\n\nTIEMPO ESTIMADO: 3 semanas\n```\n\n### Agent Swarm Brief (Tu Tarea)\n\nReescribe el plan anterior como un brief de orquestación de agentes:\n\n```markdown\n## Agent Swarm Brief: Sistema de Notificaciones\n\n### Objetivo\nConstruir un sistema de notificaciones en tiempo real para usuarios web y mobile.\n\n### Agentes a Desplegar\n\nAgente 1: [NOMBRE Y ROL]\n- Misión: [QUÉ debe explorar]\n- Output esperado: [QUÉ debe entregar]\n\nAgente 2: [NOMBRE Y ROL]\n- Misión: [QUÉ debe explorar]\n- Output esperado: [QUÉ debe entregar]\n\nAgente 3: [NOMBRE Y ROL]\n- Misión: [QUÉ debe explorar]\n- Output esperado: [QUÉ debe entregar]\n\n### Proceso de Decisión\nDespués de que los agentes entreguen sus outputs:\n1. [Criterio de decisión 1]\n2. [Criterio de decisión 2]\n3. [Decisión final basada en: ...]\n```\n\n**Escribe tu respuesta en un archivo o herramienta de notas.** Lo necesitarás en el próximo módulo.\n\n---\n\n## Resumen del Vibe Shift\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Control total** → **Orquestación** | Dejo de intentar controlarlo todo |\n| **Planificación exhaustiva** → **Exploración iterativa** | Exploro antes de planear |\n| **Pensamiento lineal** → **Exploración paralela** | Genero múltiples opciones a la vez |\n| \"**Tengo que saber**\" → \"**No sé, voy a explorar**\" | Admito ignorance y uso IA para aprender |\n\n**Checkpoint**: ¿Estás listo para dejar ir el control total y abrazar la orquestación?\n\nSi dudas sobre alguno de estos conceptos, reviste este módulo. El siguiente módulo construye directamente sobre estos fundamentos.",
      "content_url": null,
      "sort_order": 1,
      "duration_minutes": 30
    },
    {
      "title": "Modulo 2: AI Stack Reality - Claude vs GLM",
      "content_type": "markdown",
      "content": "# Modulo 2: AI Stack Reality - Claude vs GLM\n\n## La Realidad de los Modelos\n\n**No todos los modelos son iguales.**\n\nEn Fyves, usamos principalmente dos modelos de IA:\n- **Claude Opus 4.5**: Para tareas complejas de razonamiento\n- **GLM 4.7**: Para ejecución rápida y eficiente\n\nEntender **cuándo usar cada uno** es la diferencia entre:\n- ✅ Desarrollar rápido y barato\n- ❌ Gastar tiempo y dinero innecesariamente\n\n---\n\n## Fortalezas y Debilidades de Claude Opus 4.5\n\n### ✅ Fortalezas\n\n| Característica | Nivel | Notas |\n|---------------|-------|--------|\n| **Razonamiento complejo** | Exceptional | Mejor en tareas abstractas |\n| **Comprensión de contexto** | Exceptional | Entiende codebases grandes |\n| **Arquitectura de software** | Excellent | Mejor que otros modelos |\n| **Refactorización compleja** | Excellent | Encuentra patrones no obvios |\n| **Explicación técnica** | Excellent | Pedagógico y claro |\n| **Seguridad de código** | Excellent | Detecta vulnerabilidades |\n\n### ❌ Debilidades\n\n| Característica | Nivel | Notas |\n|---------------|-------|--------|\n| **Velocidad** | Lento | Puede tomar 10-30s por respuesta |\n| **Costo** | Alto | $15 por millón de tokens (input) |\n| **Longitud de respuesta** | Variable | A veces verbose innecesariamente |\n| **Tasks simples** | Sobre-calificado | Usarlo para cosas simples es desperdicio |\n\n### **¿Cuándo usar Claude Opus?**\n\n```\n✅ USA CLAUDE OPUST PARA:\n\n1. PRD profundas (Product Requirements Documents)\n   - \"Analiza este PRD y encuentra inconsistencias\"\n\n2. Arquitectura de sistemas\n   - \"Diseña la arquitectura de un sistema de pagos escalable\"\n\n3. Refactorización compleja\n   - \"Refactoriza este código para hacerlo testeable\"\n\n4. Code reviews de PRs grandes\n   - \"Revisa este PR de 5000 líneas y encuentra problemas\"\n\n5. Debugging de issues complejos\n   - \"Este error solo ocurre en producción, ¿qué puede ser?\"\n\n❌ NO USES CLAUDE OPUST PARA:\n\n1. Generar boilerplate simple\n   - \"Crea un componente de botón React\"\n   → Usa GLM 4.7 (10x más rápido y barato)\n\n2. Tests simples\n   - \"Escribe un test para esta función\"\n   → Usa GLM 4.7\n\n3. Cambios triviales\n   - \"Cambia el nombre de esta variable\"\n   → Hazlo tú mismo o usa GLM 4.7\n```\n\n---\n\n## Economía de Ejecución de GLM 4.7\n\n### ✅ Fortalezas\n\n| Característica | Nivel | Notas |\n|---------------|-------|--------|\n| **Velocidad** | Muy rápido | 2-5 segundos por respuesta |\n| **Costo** | Muy bajo | ~$0.10 por millón de tokens |\n| **Coding tasks** | Excellent | Igual de bueno que Claude para código estándar |\n| **Seguimiento de instrucciones** | Excellent | Sigue prompts muy bien |\n| **Idiomas** | Excellent | Español, inglés, chino |\n\n### ❌ Debilidades\n\n| Característica | Nivel | Notas |\n|---------------|-------|--------|\n| **Razonamiento abstracto** | Bueno, no excelente | Para arquitectura compleja, usa Claude |\n| **Contexto muy largo** | Bueno | Maneja hasta 128K tokens, pero pierde coherencia |\n| **Creatividad** | Bueno | Menos creativo que Claude |\n\n### **¿Cuándo usar GLM 4.7?**\n\n```\n✅ USA GLM 4.7 PARA:\n\n1. Generación de código estándar\n   - \"Implementa esta interfaz TypeScript\"\n   - \"Crea un componente de tarjeta en React\"\n\n2. Refactorización de código mediano\n   - \"Refactoriza esta función para usar async/await\"\n\n3. Tests unitarios\n   - \"Escribe tests para esta clase\"\n\n4. Boilerplate\n   - \"Crea la estructura de un proyecto Next.js\"\n\n5. Debugging simple\n   - \"Este código tiene un error de tipos, arréglalo\"\n\n❌ NO USES GLM 4.7 PARA:\n\n1. Arquitectura de sistemas complejos\n   - \"Diseña un sistema de mensajería distribuida\"\n   → Usa Claude Opus\n\n2. Análisis de negocio profundo\n   - \"Analiza si este PRD es viable\"\n   → Usa Claude Opus\n```\n\n---\n\n## Costo por Hora: Planning vs Ejecución\n\n### Costos Comparativos (Aproximados)\n\n| Tarea | Modelo | Tokens | Tiempo | Costo |\n|------|--------|--------|--------|------|\n| **Planificar arquitectura** | Claude Opus | 50K input + 10K output | 5 min | $1.00 |\n| **Ejecutar código simple** | GLM 4.7 | 5K input + 2K output | 30s | $0.001 |\n| **Refactor complejo** | Claude Opus | 30K input + 15K output | 8 min | $0.70 |\n| **Refactor simple** | GLM 4.7 | 10K input + 5K output | 1 min | $0.002 |\n\n**La lección**:\n- **Planning**: Usa Claude Opus (inversión que ahorra horas)\n- **Ejecución**: Usa GLM 4.7 (1000x más barato para tareas simples)\n\n### Ejemplo de Ahorro de Costos\n\n**Escenario**: Necesitas refactorizar 50 funciones en un proyecto.\n\n❌ **Método Incorrecto**:\n```\nUsar Claude Opus para todo:\n- 50 funciones × $0.10 cada una = $5.00\n- Tiempo: 50 funciones × 10 min = 8.3 horas\n```\n\n✅ **Método Correcto (Vibe Coding)**:\n```\n1. Claude Opus: \"Analiza estas 50 funciones y agrúpalas por patrón de refactorización\"\n   - Costo: $0.50\n   - Output: 5 grupos de funciones con estrategias de refactor\n\n2. GLM 4.7: \"Refactoriza estas 10 funciones usando el patrón X\"\n   - Costo: $0.02 (10 funciones × 5 refactorizaciones × $0.0004)\n   - Repite para cada grupo\n   - Tiempo total: 1 hora\n\nResultado: $0.52 total vs $5.00 (90% de ahorro)\n           1 hora vs 8.3 horas (88% más rápido)\n```\n\n---\n\n## Latencia vs Profundidad de Razonamiento\n\n### La Curva de Rendimiento\n\n```\nVelocidad (respuestas/minuto)\n↑\n│                     GLM 4.7 ████████████\n│                  Claude ████\n│                  Opus ████\n│                       ████\n└─────────────────────────────────────→\n       Razonamiento (profundidad)\n```\n\n**Trade-off**:\n- Más velocidad = Menos profundidad de razonamiento\n- Más profundidad = Más tiempo de espera\n\n### Estrategia Híbrida\n\n```\n1. Claude Opus (Profundidad):\n   - \"Analiza este problema y encuentra 3 soluciones posibles\"\n   - Tiempo: 5-10 minutos\n   - Output: 3 estrategias con pros/contras\n\n2. Tú (Decisión):\n   - Evalúas las 3 opciones\n   - Seleccionas la mejor\n\n3. GLM 4.7 (Velocidad):\n   - \"Implementa la estrategia X para este caso específico\"\n   - Tiempo: 30 segundos\n   - Output: Código funcional\n```\n\n**Resultado**: Mejor de ambos mundos - profundidad sin sacrificar velocidad.\n\n---\n\n## Estrategias de Routing Híbrido\n\n### Routing Basado en Complejidad\n\n```typescript\n// Pseudo-código de estrategia de routing\nfunction selectModel(task: Task): Model {\n  const complexity = analyzeComplexity(task)\n  \n  if (complexity === 'trivial') {\n    // No necesitas IA para esto\n    return 'human'\n  }\n  \n  if (complexity === 'simple') {\n    // Tareas estándar de código\n    return 'GLM-4.7'\n  }\n  \n  if (complexity === 'medium') {\n    // Refactorización, debugging medio\n    return 'GLM-4.7'  // Primer intento\n    // Si falla → 'Claude-Opus'\n  }\n  \n  if (complexity === 'complex') {\n    // Arquitectura, planning complejo\n    return 'Claude-Opus'\n  }\n  \n  if (complexity === 'critical') {\n    // Seguridad, producción, decisiones mayores\n    return 'Claude-Opus' + 'Human Review'\n  }\n}\n```\n\n### Routing Basado en Costo\n\n```typescript\n// Para tareas repetitivas, considera el costo acumulado\nfunction selectModelForBatch(tasks: Task[]): Model {\n  const estimatedCost = {\n    'Claude-Opus': tasks.length * 0.10,  // $0.10 por tarea\n    'GLM-4.7': tasks.length * 0.001     // $0.001 por tarea\n  }\n  \n  if (estimatedCost['Claude-Opus'] > 10) {\n    // Si va a costar más de $10, reconsidera\n    if (tasks.every(t => t.complexity === 'simple')) {\n      return 'GLM-4.7'  // 100x más barato\n    }\n  }\n  \n  return 'Claude-Opus'\n}\n```\n\n---\n\n## Comparison Lab: Tabla de Referencia\n\n### Tipo de Tarea vs Modelo Óptimo\n\n| Tipo de Tarea | Claude Opus | GLM 4.7 | Recomendación |\n|--------------|-------------|---------|---------------|\n| **PRD profundo** | Alto | Medio | Claude (mejor análisis) |\n| **Refactors** | Medio | Alto | GLM (más rápido) |\n| **Debug loops** | Bajo | Alto | GLM (iteración rápida) |\n| **Arquitectura** | Alto | Medio | Claude (más estratégico) |\n| **Boilerplate** | Bajo | Alto | GLM (o plantillas) |\n| **Code reviews** | Alto | Medio | Claude (más crítico) |\n| **Tests simples** | Medio | Alto | GLM (ejecución rápida) |\n| **Tests complejos** | Alto | Medio | Claude (mejor diseño) |\n| **Documentación** | Alto | Alto | Cualquiera (GLM es más rápido) |\n| **Migraciones** | Alto | Medio | Claude (más cuidado) |\n| **Prompt engineering** | Alto | Medio | Claude (meta-cognición) |\n\n---\n\n## Checkpoint: Elige el Modelo WRONG a Propósito\n\n**Tu turno**: Aplica lo que has aprendido.\n\n### Ejercicio\n\nPara cada tarea de abajo, **elige INTENCIONALMENTE el modelo WRONG** y explica **por qué fallaría** con ese modelo.\n\n```markdown\n## Tarea 1: Crear un componente de botón en React\n\nModelo WRONG seleccionado: __________\n\nPor qué fallaría:\n- __________\n- __________\n\n---\n\n## Tarea 2: Diseñar la arquitectura de un sistema de pagos distribuido\n\nModelo WRONG seleccionado: __________\n\nPor qué fallaría:\n- __________\n- __________\n\n---\n\n## Tarea 3: Refactorizar 100 funciones simples de JS a TypeScript\n\nModelo WRONG seleccionado: __________\n\nPor qué fallaría:\n- __________\n- __________\n\n---\n\n## Tarea 4: Debugging de un race condition en Node.js\n\nModelo WRONG seleccionado: __________\n\nPor qué fallaría:\n- __________\n- __________\n```\n\n**Escribe tus respuestas antes de continuar.** Este ejercicio solidifica tu understanding de las diferencias entre modelos.\n\n---\n\n## Resumen: AI Stack Reality\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Claude Opus** | Para razonamiento complejo, planning, arquitectura |\n| **GLM 4.7** | Para ejecución rápida, código estándar, refactor simple |\n| **Routing inteligente** | Selecciono el modelo basado en complejidad |\n| **Costo vs velocidad** | Evalúo ambos antes de elegir modelo |\n\n**Checkpoint final**: ¿Puedes explicar por qué a veces el modelo \"más potente\" es la wrong elección?\n\nLa respuesta impacta tu productividad y tu presupuesto de IA.",
      "content_url": null,
      "sort_order": 2,
      "duration_minutes": 45
    },
    {
      "title": "Modulo 3: Prompts as Architecture - CRITICO",
      "content_type": "markdown",
      "content": "# Modulo 3: Prompts as Architecture ⚠️ **CRÍTICO**\n\n> **Este es el módulo más importante de todo el curso.**\n> \n> Dominar esto es la diferencia entre \"usar IA\" y \"vibe coding\".\n\n---\n\n## Los Prompts son Especificaciones Ejecutables\n\n### Concepto Fundamental\n\nUn **prompt no es una conversación casual**. Un prompt es **código ejecutable** que:\n\n1. **Define intención**: Qué quieres lograr\n2. **Establece restricciones: Qué NO debe hacer\n3. **Especifica formato: Cómo debe entregar el resultado\n4. **Provee contexto: Información necesaria para ejecutar\n\n```\n❌ PROMPT CASUAL (Anti-vibe):\n\"Ayúdame con el código de autenticación\"\n\n✅ PROMPT COMO ESPECIFICACIÓN EJECUTABLE:\n\"Implementa el sistema de autenticación siguiendo estas especificaciones:\n\nINTENCIÓN:\n- Crear login con email/password\n- Generar JWT tokens\n- Manejar errores específicamente\n\nRESTRICCIONES:\n- NO usar bibliotecas de terceros (excepto jwt/jsonwebtoken)\n- NO almacenar passwords en texto plano (bcrypt, salt rounds=12)\n- NO permitir passwords < 8 caracteres\n\nFORMATO:\n- Entregar código TypeScript con interfaces explícitas\n- Incluir tipos para todas las funciones\n- Proveer ejemplo de uso\n\nCONTEXTO:\n- Base de datos: Supabase\n- Tabla: 'users' con columnas [id, email, password_hash, created_at]\n- Framework: Next.js 15 con App Router\"\n```\n\n---\n\n## Restriciones Estilo Ralph\n\n### ¿Qué es \"Ralph\"?\n\nRalph es el sistema de prompting de Fyves (nombrado en honor a Ralph Waldo Emerson). Define **cómo estructurar prompts para obtener resultados consistentes**.\n\n### Las 4 Políticas de Ralph\n\n#### 1. Políticas STOP\n\nDefine **qué NO debe hacer** la IA:\n\n```\nPOLÍTICAS STOP:\n- NO agregar código \"extra\" o \"bonito\"\n- NO hacer suposiciones sobre el estado de la aplicación\n- NO cambiar código que no está relacionado con la tarea\n- NO usar patrones que no estén explícitamente solicitados\n- NO incluir comentarios explicativos (salvo que se pidan)\n```\n\n**Por qué funciona**: La IA, por naturaleza, quiere \"ayudar\" agregando cosas. Las políticas STOP previenen esto.\n\n#### 2. Políticas TRUTH\n\nDefine **cómo debe manejar la verdad y la evidencia**:\n\n```\nPOLÍTICAS TRUTH:\n- SOLO incluir código basado en evidencia en el contexto\n- NO inventar funciones o métodos que no existen\n- Si no hay suficiente información, decir \"No puedo completar sin más contexto\"\n- NO asumir que existen helpers o utilidades\n```\n\n**Por qué funciona**: La IA a menudo alucina funciones o métodos que \"deberían\" existir. TRUTH previene esto.\n\n#### 3. Políticas FORMAT\n\nDefine **cómo debe estructurar el output**:\n\n```\nPOLÍTICAS FORMAT:\n- Entregar código en bloques marcados con ```lenguaje\n- NO incluir markdown fuera de los bloques de código\n- NO agregar explicaciones después del código (salvo que se pidan)\n- SIEMPRE incluir TypeScript interfaces para todo\n- Usar snake_case para nombres de base de datos, camelCase para variables\n```\n\n**Por qué funciona**: Formato consistente = output predecible = fácil de integrar.\n\n#### 4. Políticas SCOPE\n\nDefine **qué está incluido y qué está fuera de alcance**:\n\n```\nPOLÍTICAS SCOPE:\n- INCLUIR: Solo el código específicamente solicitado\n- EXCLUIR: Tests, documentación, ejemplos (salvo que se pidan)\n- EXCLUIR: Migraciones de base de datos (salvo que se pidan)\n- EXCLUIR: Configuración de deploy (salvo que se pidan)\n```\n\n**Por qué funciona**: Previene \"feature creep\" en la respuesta de la IA.\n\n---\n\n## Enforcement de Evidencia\n\n### El Principio de Evidencia\n\n**Todo output de la IA debe ser rastreable a evidencia en el prompt.**\n\n```\n❌ SIN EVIDENCIA:\nPrompt: \"Crea un sistema de usuarios\"\n\nIA: \"Aquí está un sistema completo con login, registro, perfil, \n     recuperación de password, OAuth, 2FA...\"\n     \nProblema: ¿De dónde sacó todo eso? No estaba en el prompt.\n\n✅ CON EVIDENCIA:\nPrompt: \"Crea un sistema de usuarios con ESTAS especificaciones:\n\nEVIDENCIA (interfaces ya existentes):\n```typescript\ninterface User {\n  id: string\n  email: string\n  created_at: Date\n}\n\ninterface CreateUserData {\n  email: string\n  password: string\n}\n```\n\nREQUERIMIENTO:\n- Implementa función createUser(data: CreateUserData): Promise<User>\n- Usar estos campos exactos de la interfaz User\n- NO agregar campos extras\"\n\nIA: \"Aquí está la implementación de createUser...\"\n    \n    (Solo implementa lo que se puede derivar de la evidencia)\n```\n\n### Técnica: Citado de Evidencia\n\nCuando la IA debe usar código existente:\n\n```\nPROMPT:\n\"Refactoriza ESTA función para usar async/await:\n\nEVIDENCIA (código existente):\n[pegar código aquí]\n\nRESTRICCIONES:\n- NO cambiar la lógica, solo la sintaxis\n- MANTENER todos los manejos de error existentes\n- NO agregar lógica nueva\"\n```\n\n**Regla de oro**: Si no está en EVIDENCIA, no va en el output.\n\n---\n\n## Prompts \"Describe Solo Realidad\"\n\n### El Problema de la \"Creatividad\" de la IA\n\nLa IA quiere ser \"creativa\" y \"útil\". En programación, esto es un problema:\n\n```\nPrompt: \"Implementa un cache para usuarios\"\n\nIA (creativa): \"Voy a crear un sistema de cache distribuido con Redis,\n    fallback a Memcached, invalidación automática, y métricas!\"\n    \nRealidad: Solo querías un Map<string, User> en memoria.\n```\n\n### Prompts de Realidad\n\n**\"Describe solo realidad\"** significa: **solo output lo que es real y verificable**.\n\n```\n✅ PROMPT DE REALIDAD:\n\"Implementa cache de usuarios con ESTAS restricciones:\n\nREALIDAD (lo que existe AHORA):\n- TypeScript/Node.js environment\n- No hay Redis, Memcached, o servicios externos\n- Base de datos: Supabase (no agregarás más dependencias)\n\nREQUERIMIENTO:\n- Usar Map<string, User> en memoria\n- Expirar después de 5 minutos\n- NO agregar dependencias externas\n- NO crear servicios o clases complejas\n\nENTREGA:\n- Solo una función: getUserWithCache(id: string): Promise<User>\n- Máximo 20 líneas de código\"\n\nIA (realista): \"Aquí está la función getUserWithCache usando Map...\"\n```\n\n**Resultado**: Código simple, directo, sin \"creatividad\" innecesaria.\n\n---\n\n## Ejercicio: Convierte un Bug Report Vago en Prompt de Auditoría Estricta\n\n### Bug Report Vago (Típico)\n\n```\nBug Report:\n\"El sistema de autenticación no funciona bien a veces\"\nReportado por: usuario anonimo\nFecha: hace 3 días\n```\n\n### Tu Tarea: Convierte a Prompt de Auditoría\n\nReescribe el bug report anterior como un **prompt de auditoría estricta** usando:\n\n1. **POLÍTICAS STOP** (qué NO debe hacer)\n2. **POLÍTICAS TRUTH** (solo basarse en evidencia)\n3. **POLÍTICAS SCOPE** (qué está incluido/excluido)\n4. **EVIDENCIA** (qué información recolectar)\n\n```markdown\n## Prompt de Auditoría Estricta\n\nINTENCIÓN:\n________\n\nPOLÍTICAS STOP:\n- __________\n- __________\n\nPOLÍTICAS TRUTH:\n- __________\n- __________\n\nPOLÍTICAS SCOPE:\n- INCLUIR: __________\n- EXCLUIR: __________\n\nEVIDENCIA REQUERIDA:\n- __________\n- __________\n\nOUTPUT ESPERADO:\n________\n```\n\n**Escribe tu prompt antes de continuar.**\n\n---\n\n## Checklist: Prompts como Arquitectura\n\nAntes de finalizar este módulo CRÍTICO, verifica:\n\n- [ ] Entiendo que los prompts son **código ejecutable**, no conversación\n- [ ] Sé escribir **POLÍTICAS STOP** para restringir la IA\n- [ ] Sé escribir **POLÍTICAS TRUTH** para prevenir alucinaciones\n- [ ] Sé usar **EVIDENCIA** para anclar el output deseado\n- [ ] Puedo escribir prompts de **\"realidad solo\"** para evitar creatividad innecesaria\n- [ ] Entiendo cómo convertir requisitos vagos en **prompts estrictos**\n\n**¿Tienes dudas?** Este módulo es la fundación de todo lo demás. Reviste antes de continuar.\n\n---\n\n## Resumen: Prompts as Architecture\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Prompts son especificaciones** | Los trato como código ejecutable |\n| **Políticas STOP** | Siempre defino qué NO debe hacer la IA |\n| **Políticas TRUTH** | Solo output basado en evidencia provista |\n| **Realidad solo** | Evito \"creatividad\" innecesaria de la IA |\n| **Evidencia primero** | Siempre provisto contexto explícito |\n\n**Checkpoint final**: ¿Puedes escribir un prompt que la IA NO pueda malinterpretar?\n\nEsta es la skill más importante de todo el curso.",
      "content_url": null,
      "sort_order": 3,
      "duration_minutes": 40
    },
    {
      "title": "Modulo 4: Multi-Agent Command",
      "content_type": "markdown",
      "content": "# Módulo 4: Multi-Agent Command\n\n## El Poder de Múltiples Agentes\n\nHasta ahora, has usado un solo agente de IA a la vez. Pero el **verdadero poder** del vibe coding emerge cuando orquestas **múltiples agentes especializados** trabajando en paralelo.\n\n### Analogía: El Equipo de Desarrollo\n\n```\n❌ UN SOLO AGENTE (Anti-vibe):\nUn developer fullstack que hace TODO:\n- Diseña la base de datos\n- Escribe la API\n- Construye el frontend\n- Hace el deploy\n- Configura el monitoreo\n\nProblema: No es experto en nada.\n\n✅ MULTIPLES AGENTES (Vibe coding):\nUn equipo especializado:\n- Agente DB Architect → Diseña esquemas optimizados\n- Agente API Developer → Implementa endpoints robustos\n- Agente Frontend Specialist → Construye UIs elegantes\n- Agente DevOps Engineer → Configura deployment\n- Agente QA Engineer → Escribe tests y valida calidad\n\nVentaja: Cada agente es experto en su dominio.\n```\n\n---\n\n## ¿Cuándo Dividir Agentes?\n\n### Señales de que Necesitas Dividir\n\n| Señal | Explicación | Acción |\n|-------|-------------|--------|\n| **El prompt es >500 palabras** | Demasiado contexto para un solo agente | Divide en sub-tareas |\n| **Múltiples dominios técnicos** | DB + Frontend + API en el mismo prompt | Un agente por dominio |\n| **Output necesita validación** | Agente A genera, Agente B revisa | Patrón reviewer |\n| **Divergencia de estrategias** | Necesitas comparar enfoques | Patrón council |\n| **Tareas repetitivas** | 50 funciones similares para refactorizar | Un agente worker, un supervisor |\n\n### El Test de la \"Responsabilidad Única\"\n\nAntes de crear un agente nuevo, pregúntate:\n\n```\n¿Este agente tiene UNA responsabilidad clara?\n\n✅ SÍ: \"Este agente solo diseña esquemas de base de datos\"\n   → Crea el agente\n\n❌ NO: \"Este agente hace DB, frontend y testing\"\n   → Divide en múltiples agentes\n\n❌ TAL VEZ: \"Este agente hace DB y también API\"\n   → ¿Están relacionadas? Si no, divide.\n```\n\n---\n\n## ¿Cuántos es Demasiados?\n\n### La Ley de Rendimientos Decrecientes\n\n```\nCalidad de Output\n↑\n│          ___\n│         /   ╲        (Optimal: 3-5 agentes)\n│        /     ╲___\n│       /          ╲_____\n│      /                ╲_________\n│     /                          ╲_____\n│    /                                ╲\n└─────────────────────────────────────────→\n   1   2   3   4   5   6   7   8   9   10  (Número de agentes)\n```\n\n**Observaciones**:\n- **1-2 agentes**: Mejor que nada, pero sin especialización\n- **3-5 agentes**: Zona óptima - especialización sin overhead\n- **6-8 agentes**: Overhead de coordinación empieza a costar\n- **9+ agentes**: Demasiado tiempo gestionando, poco tiempo ejecutando\n\n### Regla del Pulgar: 3-5 Agentes\n\n```\n✅ BUENA DIVISIÓN (3 agentes):\n- Agente 1: Database Architect\n- Agente 2: API Developer  \n- Agente 3: Frontend Engineer\n\n❌ DEMASIADOS AGENTES (10 agentes):\n- Agente 1: PostgreSQL Schema Designer\n- Agente 2: PostgreSQL Index Optimizer\n- Agente 3: PostgreSQL Migration Writer\n- Agente 4: REST API Architect\n- Agente 5: GraphQL API Architect\n- Agente 6: API Authentication Specialist\n- Agente 7: React Component Builder\n- Agente 8: React State Management Expert\n- Agente 9: CSS Stylist\n- Agente 10: Accessibility Specialist\n\nProblema: Pasas más tiempo coordinando que produciendo.\n```\n\n### Cuándo Romper la Regla\n\n**Excepciones donde >5 agentes tiene sentido**:\n\n```\n1. Proyectos MUY grandes (equivalente a 6+ meses de trabajo humano)\n   → Puedes justificar 6-8 agentes\n\n2. Batch processing (mismo task, 100 variaciones)\n   → Agent workers idénticos que procesan en paralelo\n\n3. Exploración masiva de arquitecturas\n   → 10 agentes con diferentes \"personalidades\"\n   → Solo para research, no para implementación\n```\n\n---\n\n## Patrones de Arbitraje de Council\n\n### Patrón 1: Council de Perspectivas\n\nUsa múltiples agentes con **diferentes puntos de vista**:\n\n```typescript\n// Ejemplo: Diseñar un sistema de autenticación\n\nconst perspectives = [\n  {\n    name: \"Security Purist\",\n    role: \"Prioriza seguridad sobre todo. NO sacrifiques seguridad por conveniencia.\",\n    task: \"Diseña un sistema de auth con máxima seguridad\"\n  },\n  {\n    name: \"UX Advocate\",\n    role: \"Prioriza experiencia de usuario. Minimiza fricción.\",\n    task: \"Diseña un sistema de auth con óptima UX\"\n  },\n  {\n    name: \"Performance Pragmatist\",\n    role: \"Prioriza velocidad y escalabilidad. Evita overhead innecesario.\",\n    task: \"Diseña un sistema de auth高性能\"\n  }\n]\n\n// Ejecutar en paralelo\nconst results = await Promise.all(\n  perspectives.map(p => Agent.run(p))\n)\n\n// Tú decides: Balancea las tres perspectivas\n```\n\n**Output esperado**:\n- Security Purist: \"OAuth2 + PKCE + 2FA obligatorio + device fingerprinting\"\n- UX Advocate: \"Magic link email, sin passwords, un solo clic\"\n- Performance Pragmatist: \"JWT stateless, Redis para blacklisting\"\n\n**Tu decisión**: Combina lo mejor de cada uno.\n\n### Patrón 2: Council de Alternativas Técnicas\n\nUsa agentes para **explorar diferentes tecnologías**:\n\n```typescript\n// Ejemplo: Seleccionar stack de realtime\n\nconst alternatives = [\n  {\n    name: \"WebSocket Traditionalist\",\n    task: \"Diseña sistema de mensajería usando WebSockets tradicionales\"\n  },\n  {\n    name: \"Server-Sent Events Evangelist\",\n    task: \"Diseña sistema de mensajería usando Server-Sent Events\"\n  },\n  {\n    name: \"WebRTC Enthusiast\",\n    task: \"Diseña sistema de mensajería usando WebRTC data channels\"\n  },\n  {\n    name: \"Polling Pragmatist\",\n    task: \"Diseña sistema de mensajería usando long-polling\"\n  }\n]\n```\n\n**Output esperado**: Cada agente defiende su tecnología con pros/contras.\n\n### Patrón 3: Council de Arbitraje (Tú eres el Juez)\n\n```typescript\n// Tú creas un \"meta-agente\" que evalúa a otros agentes\n\nconst arbiter = {\n  name: \"Chief Architect\",\n  role: \"Evalúa las propuestas de los otros agentes y selecciona la mejor\",\n  evaluationCriteria: [\n    \"Mantenibilidad a largo plazo\",\n    \"Curva de aprendizaje del equipo\",\n    \"Compatibilidad con stack existente\",\n    \"Rendimiento esperado\",\n    \"Madurez de la tecnología\"\n  ]\n}\n\n// Flujo:\n// 1. Ejecutas agentes especializados\n// 2. Das sus outputs al árbitro\n// 3. Árbitro recomienda la mejor opción\n// 4. TÚ decides la final\n```\n\n---\n\n## Previniendo Agent Echo Chambers\n\n### ¿Qué es un Echo Chamber?\n\nUn \"echo chamber\" ocurre cuando:\n\n```\nAgente A genera código\n    ↓\nAgente B revisa y aprueba (porque piensa igual)\n    ↓\nAgente C valida y refuerza (mismo sesgo)\n    ↓\nResultado: Bugs o problemas que nadie detectó\n```\n\n### Cómo Prevenir Echo Chambers\n\n#### Estrategia 1: Personalidades Contrapuestas\n\n```typescript\nconst reviewers = [\n  {\n    name: \"Optimistic Builder\",\n    bias: \"Tiende a aprobar rápido y construir\"\n  },\n  {\n    name: \"Critical Skeptic\",\n    bias: \"Siempre encuentra problemas y edge cases\",\n    task: \"Encuentra 5 problemas potenciales en este código\"\n  },\n  {\n    name: \"Security Paranoid\",\n    bias: \"Ve vulnerabilidades en todo\",\n    task: \"Encuentra 3 vulnerabilidades de seguridad\"\n  }\n]\n```\n\n**Regla**: Siempre incluye al menos un agente \"devil's advocate\".\n\n#### Estrategia 2: Evidencia Obligatoria\n\n```typescript\nconst reviewerWithEvidence = {\n  name: \"Evidence-Based Reviewer\",\n  requirements: [\n    \"Para cada aprobación, cita evidencia del código\",\n    \"Para cada crítica, muestra el line exacto del problema\",\n    \"NO usar frases vagas como 'parece bien' o 'me preocupa'\"\n  ]\n}\n```\n\n#### Estrategia 3: Blind Review\n\n```typescript\n// Agente A genera código\nconst code = await Agent.generate({\n  name: \"Builder\",\n  task: \"Implementa función de auth\"\n})\n\n// Agente B revisa SIN saber quién lo escribió\nconst review = await Agent.review({\n  name: \"Blind Reviewer\",\n  context: \"Este código fue escrito por un developer senior. \n              Encuentra bugs sin ser indulgente.\",\n  code: code  // NO incluyes metadata del autor\n})\n```\n\n---\n\n## Escenario en Vivo: Un Sistema, Cinco Agentes en Conflicto\n\n### El Problema\n\n```\nREQUERIMIENTO:\n\"Construir un sistema de comentarios para una plataforma de contenido.\n\nRequisitos:\n- Usuarios pueden comentar\n- Comentarios pueden tener respuestas (nested)\n- Moderación de contenido tóxico\n- Notificaciones en tiempo real\n- Escalabilidad: 10M comentarios por día\"\n```\n\n### Los Cinco Agentes (y sus Conflictos)\n\n```typescript\nconst agents = [\n  {\n    name: \"SQL Purist\",\n    approach: \"Usa recursión de PostgreSQL para comentarios nested\",\n    bias: \"Todo debe ser relacional, normalizado y ACID-compliant\"\n  },\n  \n  {\n    name: \"NoSQL Rebel\",\n    approach: \"Usa MongoDB con documents embebidos para threads\",\n    bias: \"La estructura de documentos es más natural que relaciones\"\n  },\n  \n  {\n    name: \"Realtime Fanatic\",\n    approach: \"WebSockets para todo, sin polling\",\n    bias: \"Si no es realtime, no es moderno\"\n  },\n  \n  {\n    name: \"Cache-First Evangelist\",\n    approach: \"Redis para todo, la DB es solo source of truth\",\n    bias: \"Si no está en cache, no existe\"\n  },\n  \n  {\n    name: \"Microservices Zealot\",\n    approach: \"Separa en 5 servicios: Comments, Moderation, Notifications, Analytics, Spam-Detection\",\n    bias: \"Un servicio por responsabilidad\"\n  }\n]\n```\n\n### Los Conflictos\n\n| Conflicto | Agentes involucrados | Naturaleza del conflicto |\n|-----------|---------------------|-------------------------|\n| **SQL vs NoSQL** | Purist vs Rebel | Estrategia fundamental de almacenamiento |\n| **Cache vs DB** | Fanatic vs Purist | ¿Es la DB la primary source? |\n| **Monolith vs Microservices** | Zealot vs todos | Complejidad operacional |\n| **Realtime vs Scalability** | Fanatic vs Purist | ¿Podemos escalar WebSockets a 10M? |\n\n### El Problema del Empate\n\n```\nResultado del Council:\n- SQL Purist: \"10M comentarios por día en recursión PostgreSQL será lento\"\n- NoSQL Rebel: \"MongoDB puede manejarlo, pero pierdes consistencia\"\n- Realtime Fanatic: \"WebSockets a esa escala requiere un architecture change\"\n- Cache-First Evangelist: \"Redis para todo es costoso a 10M/day\"\n- Microservices Zealot: \"5 servicios es overkill para MVP\"\n\nEmpate técnico: Nadie tiene una solución perfecta.\n```\n\n---\n\n## Resolviendo sin Reescribir Código\n\n### Técnica 1: Decision Framework\n\nEn lugar de dejar que los agentes debatan infinitamente, **tú defines un framework de decisión**:\n\n```typescript\nconst decisionFramework = {\n  criteria: [\n    { name: \"Time to MVP\", weight: 5 },      // Importancia: 1-10\n    { name: \"Development Cost\", weight: 4 },\n    { name: \"Operational Complexity\", weight: 3 },\n    { name: \"Scalability Path\", weight: 2 },\n    { name: \"Team Familiarity\", weight: 4 }\n  ],\n  \n  scoring: (proposal) => {\n    return proposal.scoreAgainst(criteria)\n  }\n}\n\n// Aplicas el framework a cada propuesta de agente\nconst scores = agents.map(agent => ({\n  name: agent.name,\n  score: decisionFramework.scoring(agent.approach)\n}))\n\n// Ordenas por score y seleccionas el top\nconst winner = scores.sort((a, b) => b.score - a.score)[0]\n```\n\n### Técnica 2: Híbrida Estratégica\n\n**No tengas que elegir SOLO una opción**:\n\n```\nSOLUCIÓN HÍBRIDA:\n- Fase 1 (MVP): SQL Purist approach (PostgreSQL + recursión simple)\n  → Rápido de implementar, team lo conoce\n  \n- Fase 2 (Scale): Añades Cache-First para reads frecuentes\n  → Añades Redis como read-through cache\n  \n- Fase 3 (Realtime): Añades WebSockets SOLO para notificaciones\n  → No reescribes todo, solo añades capa de realtime\n  \n- Fase 4 (Microservices): Solo extraes Moderación si es necesario\n  → No microservices desde día 1\n```\n\n**Resultado**: Ningún agente \"gana\", todos contribuyen a una estrategia evolutiva.\n\n### Técnica 3: Constraint-Based Resolution\n\n```typescript\n// En lugar de debatir, defines restricciones claras\nconst constraints = {\n  maxDevelopmentTime: \"2 semanas\",\n  maxInfrastructureCost: \"$500/mes\",\n  teamSize: 2,  // Solo 2 developers\n  mustSupport: [\"PostgreSQL\", \"Vercel deployment\"],\n  cannotUse: [\"Kubernetes\", \"MongoDB\"]  // Stack ya definido\n}\n\n// Filtras propuestas de agentes basado en restricciones\nconst viableProposals = agents\n  .map(a => a.approach)\n  .filter(p => p.satisfies(constraints))\n\n// Si solo una propuesta pasa restricciones, esa es la winner\nif (viableProposals.length === 1) {\n  return viableProposals[0]\n}\n```\n\n### Técnica 4: Prototype y Aprende\n\n```\nEn lugar de debatir teóricamente:\n\n1. Pide a cada agente que genere un PROTOTIPO funcional\n   - Mínimo viable, no production-ready\n   - Max 200 líneas de código\n   - Enfocado en el risk específico\n\n2. Tú ejecutas los prototipos localmente\n   - Mide performance real\n   - Evalúa complejidad de código\n   - Prueba edge cases\n\n3. Tomas decisión basada en EVIDENCIA, no argumentos\n```\n\n---\n\n## Ejercicio: Diseña tu Propio Council\n\n### Escenario\n\n```\nPROYECTO: Sistema de gamificación para una app de fitness\n\nREQUERIMIENTOS:\n- Usuarios ganan puntos por ejercicio completado\n- Leaderboards semanales\n- Badges y logros\n- Streak tracking (días consecutivos)\n- Notificaciones cuando amigos superan tu score\n\nCONTEXTO:\n- Stack: Next.js + Supabase + Vercel\n- Team: 2 developers mid-level\n- Timeline: 3 semanas para MVP\n- Usuarios esperados: 10K en el primer mes\n```\n\n### Tu Tarea\n\nDiseña un **council de 3-5 agentes** para abordar este proyecto:\n\n```markdown\n## Council Design: Sistema de Gamificación\n\n### Agentes del Council\n\n**Agente 1: [NOMBRE]**\n- Responsabilidad: [QUÉ explora/decide]\n- Personalidad/Bias: [e.g., \"optimista\", \"crítico\", \"conservador\"]\n- Output esperado: [QUÉ entrega]\n\n**Agente 2: [NOMBRE]**\n- Responsabilidad: [QUÉ explora/decide]\n- Personalidad/Bias: [e.g., \"optimista\", \"crítico\", \"conservador\"]\n- Output esperado: [QUÉ entrega]\n\n**Agente 3: [NOMBRE]**\n- Responsabilidad: [QUÉ explora/decide]\n- Personalidad/Bias: [e.g., \"optimista\", \"crítico\", \"conservador\"]\n- Output esperado: [QUÉ entrega]\n\n### Estrategia de Resolución de Conflictos\n\nSi los agentes están en desacuerdo:\n1. [Tu primera estrategia]\n2. [Tu segunda estrategia]\n3. [Criterio final de decisión]\n\n### Prevención de Echo Chambers\n\n- [Cómo asegurarás que los agentes no refuercen sesgos mutuos]\n- [Qué agente será el \"devil's advocate\"]\n```\n\n**Escribe tu diseño antes de continuar.**\n\n---\n\n## Checklist: Multi-Agent Command\n\nAntes de finalizar, verifica:\n\n- [ ] Entiendo **cuándo dividir** en múltiples agentes\n- [ ] Conozco la **regla del 3-5 agentes** y cuándo romperla\n- [ ] Puedo diseñar un **council** con perspectivas diversas\n- [ ] Sé prevenir **echo chambers** con agentes contrapuestos\n- [ ] Tengo estrategias para **resolver conflictos** sin reescribir código\n- [ ] Puedo crear **soluciones híbridas** que combinan lo mejor de múltiples propuestas\n\n---\n\n## Resumen: Multi-Agent Command\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **3-5 agentes óptimo** | Me mantengo en la zona de especialización sin overhead |\n| **Council de perspectivas** | Uso agentes con diferentes puntos de vista |\n| **Decision frameworks** | Tengo criterios claros para seleccionar propuestas |\n| **Soluciones híbridas** | Combino lo mejor de múltiples enfoques |\n| **Anti echo-chamber** | Siempre incluyo un devil's advocate |\n\n**Checkpoint**: ¿Puedes diseñar un council que resuelva un problema complejo sin quedarse en debate infinito?\n\nLa habilidad de orquestar múltiples agentes es lo que separa a los vibe coders junior de los senior.",
      "content_url": null,
      "sort_order": 4,
      "duration_minutes": 45
    },
    {
      "title": "Modulo 5: Infrastructure Awareness",
      "content_type": "markdown",
      "content": "# Módulo 5: Infrastructure Awareness\n\n## El Borde entre Código e Infraestructura\n\nEn vibe coding, **la línea entre \"bug de código\" y \"bug de infraestructura\" es borrosa**.\n\nUn \"vibe coder\" experto sabe identificar:\n- ❌ \"Este es un bug de lógica\"\n- ❌ \"Este es un bug de infraestructura\"  \n- ❌ \"Este es un bug de configuración\"\n\n---\n\n## Deploy en Vercel vs Netlify\n\n### Comparativa Técnica\n\n| Característica | Vercel | Netlify | Recomendación Vibe Coding |\n|---------------|--------|---------|---------------------------|\n| **Build speed** | Muy rápido | Rápido | Vercel para proyectos grandes |\n| **Edge functions** | Excelente | Bueno | Vercel para edge-heavy apps |\n| **Preview deployments** | Automáticos por PR | Automáticos por PR | Empate, ambos excelentes |\n| **Configuration** | vercel.json | netlify.toml | Vercel más simple |\n| **Environment variables** | Por entorno | Por entorno | Empate |\n| **Serverless functions** | Built-in | Built-in | Vercel más maduro |\n| **Costo** | Gratis hasta cierto punto | Gratis hasta cierto punto | Empate en tier gratuito |\n| **TypeScript support** | Nativo | Nativo | Empate |\n| **DDoS protection** | Built-in (básico) | Built-in (básico) | Empate |\n\n### Cuándo Elegir Cada Uno\n\n```\n✅ ELIGE VERCEL SI:\n\n1. Usas Next.js\n   - Vercel creó Next.js, integración perfecta\n   - Image optimization automático\n   - ISR (Incremental Static Regeneration) out-of-the-box\n\n2. Necesitas Edge Functions\n   - Vercel Edge Functions son más maduras\n   - Mejor DX para edge routing\n\n3. Proyecto grande/enterprise\n   - Vercel tiene mejor soporte para equipos grandes\n   - Enterprise features más completas\n\n✅ ELIGE NETLIFY SI:\n\n1. Stack Jamstack (Hugo, Astro, Jekyll)\n   - Netlify empezó como SSG host\n   - Mejor soporte para generators variados\n\n2. Necesitas deploy previews complejos\n   - Netlify tiene mejor branching en planes gratis\n\n3. Prefieres configuración declarativa\n   - netlify.toml es muy flexible\n   - Redirect rules más potentes\n\n```\n\n### Ejemplo de Configuración: netlify.toml\n\n```toml\n# netlify.toml - Configuración declarativa de Netlify\n\n[build]\n  command = \"bun run build\"\n  publish = \".next\"\n\n[build.environment]\n  NODE_VERSION = \"20\"\n  NPM_FLAGS = \"--legacy-peer-deps\"\n\n[[plugins]]\n  package = \"@netlify/plugin-nextjs\"\n\n[[redirects]]\n  from = \"/api/*\"\n  to = \"/.netlify/functions/:splat\"\n  status = 200\n\n[dev]\n  command = \"bun dev\"\n  port = 3000\n  publish = \".next\"\n```\n\n### Ejemplo de Configuración: vercel.json\n\n```json\n{\n  \"buildCommand\": \"bun run build\",\n  \"devCommand\": \"bun dev\",\n  \"installCommand\": \"bun install\",\n  \"framework\": \"nextjs\",\n  \"regions\": [\"iad1\"],\n  \"functions\": {\n    \"api/**/*.ts\": {\n      \"maxDuration\": 30\n    }\n  },\n  \"rewrites\": [\n    {\n      \"source\": \"/api/:path*\",\n      \"destination\": \"/api/:path*\"\n    }\n  ]\n}\n```\n\n### Traps Comunes de Deploy\n\n| Trap | Síntoma | Causa | Solución |\n|------|---------|-------|----------|\n| **Build local funciona, deploy falla** | TypeError: Cannot find module | Dependencias faltantes en package.json | Asegúrate que todas deps están en dependencies, no devDependencies |\n| **Environment variables undefined** | process.env.VAR es undefined en producción | Variables no seteadas en plataforma | Configura en dashboard de Vercel/Netlify |\n| **Images rotas en deploy** | 404 en /_next/image | Optimización de imágenes mal configurada | Revisa next.config.js images.domain |\n| **API routes 404** | /api/hello returns 404 | Rewrite rules mal configurados | Revisa vercel.json o netlify.toml redirects |\n| **Build timeout** | Deploy se cancela después de X minutos | Build muy lento | Optimiza build time (caching, paralelización) |\n\n---\n\n## Error Truth con Sentry\n\n### ¿Qué es Sentry?\n\nSentry es una plataforma de **error tracking** que te da:\n- Errores en tiempo real de producción\n- Stack traces completas\n- Contexto de usuario, navegador, entorno\n- Releases tracking (qué release introdujo qué bug)\n\n### Configuración Básica en Next.js\n\n```typescript\n// sentry.client.config.ts\nimport * as Sentry from \"@sentry/nextjs\"\n\nSentry.init({\n  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,\n  tracesSampleRate: 1.0,\n  \n  // Integraciones útiles\n  integrations: [\n    new Sentry.BrowserTracing(),\n    new Sentry.Replay({\n      maskAllText: true,\n      blockAllMedia: true,\n    }),\n  ],\n  \n  // Filtra errores que no quieres trackear\n  beforeSend(event, hint) {\n    // Ignora errores deextensiones de navegador\n    if (event.exception?.values?.[0]?.value?.includes('Extension')) {\n      return null\n    }\n    return event\n  }\n})\n```\n\n### Error Truth: Distinguir Tipos de Errores\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 CLASIFICACIÓN DE ERRORES                 │\n├─────────────────────────────────────────────────────────┤\n│                                                          │\n│  1. BUG DE LÓGICA (Código)                              │\n│     - Error algorítmico                                  │\n│     - Caso edge no considerado                          │\n│     - Estado inconsistente                              │\n│     → FIX: Reescribe lógica del código                  │\n│                                                          │\n│  2. BUG DE INFRAESTRUCTURA (Deploy/Config)              │\n│     - Environment variables missing                      │\n│     - CORS mal configurado                              │\n│     - Deploy timeout                                    │\n│     → FIX: Cambia config de plataforma                  │\n│                                                          │\n│  3. BUG DE RUNTIME (Runtime errors)                     │\n│     - TypeError, ReferenceError                         │\n│     - Network timeout                                   │\n│     - Database connection failed                        │\n│     → FIX: Agrega error handling, retries, fallbacks    │\n│                                                          │\n│  4. BUG DE CONFIGURACIÓN (App config)                   │\n│     - next.config.js mal configurado                    │\n│     - Env variables con typos                           │\n│     - Feature flags mal seteados                        │\n│     → FIX: Corrige configuración local                  │\n│                                                          │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Ejemplo: Error Truth en Práctica\n\n```typescript\n// Ejemplo 1: ¿Es bug de código o de infra?\n\nasync function getUser(id: string) {\n  const user = await db.users.findUnique({ where: { id } })\n  return user\n}\n\n// Si esto falla con \"Cannot connect to database\":\n// → BUG DE INFRAESTRUCTURA\n//   La DB no está accesible desde deploy (firewall, whitelist IP, etc.)\n\n// Si esto falla con \"Cannot read property 'id' of undefined\":\n// → BUG DE CÓDIGO\n//   No estás manejando el caso donde user no existe\n\nasync function getUserSafe(id: string) {\n  const user = await db.users.findUnique({ where: { id } })\n  \n  // FIX de código: Maneja el null case\n  if (!user) {\n    throw new Error(`User ${id} not found`)\n  }\n  \n  return user\n}\n\n// Ejemplo 2: ¿Es bug de config o de deploy?\n\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: ['example.com'],  // Configuración correcta\n  }\n}\n\n// Si images rotan con \"Invalid src\":\n// → Revisa si example.com está en domains\n// → Si está, pero aún falla: BUG DE INFRA (CDN issue)\n```\n\n---\n\n## Build-time vs Runtime Bugs\n\n### Build-time Bugs (Detectados en Compilación)\n\n```\n✅ BUILD-TIME BUGS (Mejor tipo de bug)\n\n1. TypeScript errors\n   - Type mismatches detectados en compilación\n   - Ventaja: No llegan a producción\n   \n2. Lint errors\n   - Código que viola reglas de estilo\n   - Ventaja: Previene inconsistencias\n   \n3. Import resolution errors\n   - Módulos no encontrados\n   - Ventaja: Falle el build, no el runtime\n\n4. Environment variable validation\n   - Variables requeridas faltantes\n   - Ventaja: Falle antes de deploy\n```\n\n**Ejemplo de prevención de build-time bugs**:\n\n```typescript\n// lib/env.ts - Validación en build-time\n\nconst requiredEnvVars = [\n  'DATABASE_URL',\n  'NEXTAUTH_SECRET',\n  'API_KEY'\n] as const\n\n// Esto corre en build-time, si falla → build falla\nconst missing = requiredEnvVars.filter(\n  key => !process.env[key]\n)\n\nif (missing.length > 0) {\n  throw new Error(\n    `Missing required environment variables: ${missing.join(', ')}`\n  )\n}\n\n// Exporta tipos seguros\ntype Env = typeof requiredEnvVars[number]\n\nexport function getEnv(key: Env): string {\n  const value = process.env[key]\n  if (!value) {\n    throw new Error(`Environment variable ${key} is not defined`)\n  }\n  return value\n}\n```\n\n### Runtime Bugs (Detectados en Ejecución)\n\n```\n❌ RUNTIME BUGS (Peor tipo de bug)\n\n1. Type coercion errors\n   - \"5\" + 3 = \"53\" en lugar de 8\n   - Solo se detecta cuando el código ejecuta\n   \n2. Null/undefined access\n   - Cannot read property 'X' of undefined\n   - Solo ocurre con ciertos datos\n   \n3. Network errors\n   - API timeouts, connection refused\n   - Dependientes de condiciones externas\n   \n4. Race conditions\n   - Operaciones asíncronas en orden incorrecto\n   - Solo ocurre bajo carga específica\n```\n\n**Prevención de runtime bugs**:\n\n```typescript\n// ❌ MAL: Runtime bug esperando a ocurrir\n\nfunction calculateTotal(price: number, quantity: number) {\n  // Si price viene de API como string...\n  return price * quantity  // \"5\" * 3 = NaN en runtime!\n}\n\n// ✅ BIEN: Prevención en build-time\n\ninterface PriceInput {\n  price: number\n  quantity: number\n}\n\nfunction calculateTotal(input: PriceInput): number {\n  // TypeScript fuerza que ambos sean números\n  return input.price * input.quantity\n}\n\n// ✅ MEJOR: Validación en runtime + type safety\n\nfunction calculateTotalSafe(input: unknown): number {\n  // Validación en runtime\n  if (typeof input !== 'object' || !input) {\n    throw new Error('Input must be an object')\n  }\n  \n  const { price, quantity } = input as Record<string, unknown>\n  \n  if (typeof price !== 'number' || typeof quantity !== 'number') {\n    throw new Error('Price and quantity must be numbers')\n  }\n  \n  return price * quantity\n}\n```\n\n### Tabla de Comparación\n\n| Aspecto | Build-time | Runtime |\n|---------|-----------|---------|\n| **Cuándo se detecta** | En compilación/deploy | En producción (peor) |\n| **Impacto en usuario** | Ninguno (build falla) | Sí (error en producción) |\n| **Facilidad de debug** | Alta (stack trace claro) | Baja (depende de logging) |\n| **Costo de arreglo** | Bajo (local) | Alto (hotfix, deploy) |\n| **Prevención** | TypeScript, ESLint, tests | Zod, validation, error handling |\n\n---\n\n## Cost Traps at Scale\n\n### Trap #1: Orphaned Edge Functions\n\n```typescript\n// ❌ PROBLEMA: Creas múltiples edge functions\n\n// app/api/user/route.ts → Edge function\n// app/api/user/[id]/route.ts → Edge function\n// app/api/user/[id]/posts/route.ts → Edge function\n\n// En Vercel Hobby: 100GB-hours gratis/mes\n// Cada edge function cuenta como uso separado\n\n// Con 10 edge functions:\n// - 10 invocaciones/segundo × 60 seg × 60 min × 24 horas × 30 días\n// = 25,920,000 invocaciones\n// = Aprox 50GB-hours cada una\n// = 500GB-hours total\n// = $10-20 USD/mes solo en edge functions\n```\n\n**Solución**: Consolidar en rutas más amplias\n\n```typescript\n// ✅ SOLUCIÓN: Una sola edge function con routing interno\n\n// app/api/[[...slug]]/route.ts - Single edge function\nexport async function GET(req: Request) {\n  const path = new URL(req.url).pathname\n  \n  if (path.startsWith('/api/user')) {\n    return handleUserRequest(req)\n  }\n  \n  if (path.startsWith('/api/posts')) {\n    return handlePostsRequest(req)\n  }\n  \n  // etc.\n}\n```\n\n### Trap #2: Database Connection Pool Exhaustion\n\n```typescript\n// ❌ PROBLEMA: Creas nueva conexión por request\n\n// app/api/users/route.ts\nimport { createClient } from '@supabase/supabase-js'\n\nexport async function GET() {\n  const supabase = createClient(...)  // NUEVA CONEXIÓN CADA REQUEST\n  const users = await supabase.from('users').select('*')\n  return Response.json(users)\n}\n\n// Con 1000 requests/segundo:\n// - 1000 conexiones nuevas por segundo\n// - Supabase free tier: 60 concurrent connections\n// - Pro plan: 500 concurrent connections\n// - Resultado: Connection pool exhausted, errores 503\n```\n\n**Solución**: Singleton client con connection pooling\n\n```typescript\n// ✅ SOLUCIÓN: Una sola conexión compartida\n\n// lib/supabase.ts - Singleton\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!\n\nexport const supabase = createClient(supabaseUrl, supabaseKey, {\n  auth: {\n    persistSession: false,\n    autoRefreshToken: false,\n  },\n  db: {\n    schema: 'public',\n  },\n  global: {\n    headers: {\n      'x-my-custom-header': 'my-app-name',\n    },\n  },\n})\n\n// app/api/users/route.ts\nimport { supabase } from '@/lib/supabase'\n\nexport async function GET() {\n  const users = await supabase.from('users').select('*')  // REUSA CONEXIÓN\n  return Response.json(users)\n}\n```\n\n### Trap #3: Image Optimization Costs\n\n```typescript\n// ❌ PROBLEMA: Optimizas imágenes sin estratégia\n\n<Image \n  src=\"/hero-image.jpg\" \n  width={1920} \n  height={1080} \n  priority  // Carga inmediata, sin lazy load\n/>\n\n// En Vercel Hobby: 100GB bandwidth gratis/mes\n// Hero image de 2MB optimizado a 500KB\n// 1000 pageviews × 500KB = 500GB bandwidth\n// = $20 USD/mes solo en bandwidth de imágenes\n```\n\n**Solución**: Optimización estratégica\n\n```typescript\n// ✅ SOLUCIÓN 1: Lazy load para no-hero images\n<Image \n  src=\"/gallery-image.jpg\" \n  width={800} \n  height={600} \n  loading=\"lazy\"  // Default en Next.js 13+\n/>\n\n// ✅ SOLUCIÓN 2: CDN externo para imágenes estáticas\n<Image \n  src=\"https://cdn.example.com/hero-image.jpg\"  // Cloudflare/ImageKit\n  width={1920} \n  height={1080} \n  priority\n/>\n\n// ✅ SOLUCIÓN 3: Tamaños responsive\n<Image \n  src=\"/hero-image.jpg\" \n  width={1920} \n  height={1080} \n  sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n  // Servirá versión apropiada para cada dispositivo\n/>\n```\n\n### Tabla de Costos Comunes\n\n| Recurso | Gratis (Hobby) | Pro | Trap común |\n|---------|---------------|-----|-----------|\n| **Edge Functions** | 100GB-hrs/mes | 1000GB-hrs/mes ($20) | Múltiples funciones pequeñas |\n| **Serverless Functions** | 100GB-hrs/mes | 1000GB-hrs/mes ($20) | Funciones lentas (>10s) |\n| **Bandwidth** | 100GB/mes | 1TB/mes ($20) | Imágenes no optimizadas |\n| **Build minutes** | 6000 min/mes | Ilimitado | Builds lentos innecesarios |\n| **Database connections** | 60 concurrent | 500 concurrent | Nueva conexión por request |\n\n---\n\n## Checkpoint: ¿Bug de Código, Infra, o Config?\n\n### Ejercicio de Diagnóstico\n\nPara cada escenario, diagnostica si es:\n- **A**: Bug de código (lógica)\n- **B**: Bug de infraestructura (deploy/platform)\n- **C**: Bug de configuración (app config/env)\n\n```markdown\n## Escenario 1\n\nError: \"TypeError: Cannot read property 'map' of undefined\"\nUbicación: Línea 45 de app/users/page.tsx\nCódigo: users.map(u => <UserCard key={u.id} user={u} />)\nContexto: users viene de useSWR('/api/users')\n\nDiagnóstico: ___\nJustificación: ___\n\n---\n\n## Escenario 2\n\nError: \"API key not found\"\nUbicación: Línea 12 de lib/openai.ts\nCódigo: const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\nContexto: Funciona en local, falla en Vercel deploy\n\nDiagnóstico: ___\nJustificación: ___\n\n---\n\n## Escenario 3\n\nError: \"CORS policy: No 'Access-Control-Allow-Origin' header\"\nUbicación: Navegador, al llamar /api/external\nCódigo: fetch('https://external-api.com/data')\nContexto: Funciona en local, falla en producción (Netlify)\n\nDiagnóstico: ___\nJustificación: ___\n\n---\n\n## Escenario 4\n\nError: \"Module not found: Can't resolve '@/components/Button'\"\nUbicación: Tiempo de build en Vercel\nCódigo: import { Button } from '@/components/Button'\nContexto: Funciona en local, falla en deploy\n\nDiagnóstico: ___\nJustificación: ___\n\n---\n\n## Escenario 5\n\nError: \"Error: connect ETIMEDOUT\"\nUbicación: Línea 8 de lib/db.ts\nCódigo: await client.connect()\nContexto: Funciona en local, falla intermitentemente en producción\n\nDiagnóstico: ___\nJustificación: ___\n```\n\n**Escribe tus diagnósticos antes de continuar.**\n\n---\n\n## Checklist: Infrastructure Awareness\n\nAntes de finalizar, verifica:\n\n- [ ] Sé elegir entre **Vercel vs Netlify** basado en stack\n- [ ] Puedo configurar **vercel.json** y **netlify.toml**\n- [ ] Entiendo cómo usar **Sentry** para error tracking\n- [ ] Puedo distinguir entre **build-time vs runtime bugs**\n- [ ] Conozco los **cost traps** comunes de serverless\n- [ ] Puedo diagnosticar si un bug es de **código, infra, o config**\n\n---\n\n## Resumen: Infrastructure Awareness\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Vercel vs Netlify** | Elijo basado en stack (Next.js → Vercel, SSG → Netlify) |\n| **Error truth** | Uso Sentry para tracking y diagnóstico |\n| **Build-time > Runtime** | Prefiero errores en compilación que en producción |\n| **Cost awareness** | Entiendo costos de serverless antes de implementar |\n| **Debug classification** | Identifico rápidamente si bug es código, infra o config |\n\n**Checkpoint final**: ¿Puedes ver un error en producción y saber inmediatamente si es código, infra o config?\n\nEsta skill te ahorra horas de debugging.",
      "content_url": null,
      "sort_order": 5,
      "duration_minutes": 30
    },
    {
      "title": "Modulo 6: IDEs & Execution",
      "content_type": "markdown",
      "content": "# Módulo 6: IDEs & Execution\n\n## El Entorno de Desarrollo Vibe Coder\n\nTu **IDE (Integrated Development Environment)** es tu cockpit. En vibe coding, la elección y configuración de tu IDE impacta directamente tu velocidad.\n\n---\n\n## Cursor vs Claude Code vs VS Code Pure\n\n### Comparativa Completa\n\n| Característica | Cursor | Claude Code | VS Code Pure |\n|---------------|--------|-------------|--------------|\n| **IA integrada** | ✅ Propietaria (GPT-4/Claude) | ✅ Nativa (Claude Opus) | ❌ Requiere extensión |\n| **Completion de código** | ⭐⭐⭐⭐⭐ Excelente | ⭐⭐⭐⭐ Muy bueno | ⭐⭐⭐ Promedio |\n| **Chat integrado** | ✅ Sidebar | ✅ Native | ❌ Requiere extensión |\n| **Command palette AI** | ✅ Cmd+K (edit), Cmd+L (chat) | ✅ /prompt commands | ❌ No nativo |\n| **Multi-file editing** | ✅ Strong | ✅ Strong | ⚠️ Limitado |\n| **Context awareness** | ⭐⭐⭐⭐⭐ Muy alto | ⭐⭐⭐⭐ Alto | ⭐⭐⭐ Medio |\n| **Costo** | $20/mes (Pro) | $20/mé (Pro) | Gratis + extensions |\n| **Privacidad** | ⚠️ Código enviado a servidores | ⚠️ Código enviado a Anthropic | ✅ Local (sin extensions) |\n| **Extensiones compatibles** | ✅ VS Code extensions | ✅ VS Code extensions | ✅ Todas |\n| **Velocidad** | ⚠️ Puede ser lento en projects grandes | ⚠️ Puede ser lento | ✅ Muy rápido |\n| **Learning curve** | Baja (VS Code + IA) | Media (nuevos paradigmas) | Baja (VS Code estándar) |\n\n### Cuándo Usar Cada Uno\n\n```\n✅ CURSOR SI:\n\n1. Quieres IA integrada sin configuración\n   - \"Out of the box\" experience\n   - Cmd+K para edits inline es muy bueno\n   - Cmd+L para chat contextual\n\n2. Trabajas en proyectos comerciales\n   - Context awareness excelente\n   - Autocomplete muy rápido\n   - Multi-file edits inteligentes\n\n3. No te importa pagar $20/mes\n   - El tiempo ahorrado vale más que el costo\n   - Para vibe coders serios, es una inversión\n\n❌ CURSOR NO SI:\n\n- Código hypersensitive (no puedes enviar a IA)\n- Quieres control total sobre qué envías a IA\n- Tu laptop es muy lenta (Cursor es resource-heavy)\n\n✅ CLAUDE CODE SI:\n\n1. Quieres la mejor IA para razonamiento\n   - Claude Opus integrado nativamente\n   - Mejor que Cursor para tareas complejas\n\n2. Quieres workflows de \"agent swarm\"\n   - Claude Code tiene skills nativas para council, agents\n   - Mejor para orquestación compleja\n\n3. Trabajas en proyectos open source o personales\n   - Más orientado a developers individuales\n   - Skills específicas para debugging, testing, etc.\n\n❌ CLAUDE CODE NO SI:\n\n- Tu equipo usa VS Code estándar\n- Quieres algo más \"probado\" (Cursor es más maduro)\n- No quieres adaptarte a nuevos paradigmas\n\n✅ VS CODE PURE SI:\n\n1. Código hypersensitive o compliance stricta\n   - No puedes enviar código a servicios externos\n   - Necesitas environment completamente offline\n\n2. Quieres control total\n   - Solo extensions que tú eliges\n   - Nada de \"phone home\" o telemetry\n\n3. Recursos limitados\n   - VS Code puro es más ligero\n   - Corre en hardware más antiguo\n\n❌ VS CODE PURE NO SI:\n\n- Quieres IA integrada out-of-the-box\n- No quieres configurar extensions manualmente\n- Estás acostumbrado a Cmd+K de Cursor\n```\n\n### Feature Face-off: Cmd+K (Cursor) vs /prompt (Claude Code)\n\n```\nCURSOR: Cmd+K (Edit mode)\n\n1. Seleccionas código\n2. Presionas Cmd+K\n3. Escribes instrucción\n4. Cursor muestra diff inline\n5. Aceptas o rechazas cambios\n\nVentaja:\n- Muy rápido para edits pequeños\n- Diff inline es claro\n- No necesitas salir del editor\n\nDesventaja:\n- No entiende contexto del proyecto completo\n- Solo edits inline, no puede crear archivos nuevos\n\n---\n\nCLAUDE CODE: /prompt (Command mode)\n\n1. Escribes /prompt en el chat\n2. Das instrucción con contexto\n3. Claude Code usa múltiples tools (Read, Edit, Glob, etc.)\n4. Hace cambios multi-file si es necesario\n5. Muestra resumen de cambios\n\nVentaja:\n- Entiende contexto completo del proyecto\n- Puede hacer cambios multi-file\n- Tiene acceso a herramientas (terminal, git, etc.)\n\nDesventaja:\n- Más lento para edits pequeños\n- Puede cambiar más de lo que quieres\n```\n\n### Tabla de Decisiones Rápidas\n\n| Tarea | Mejor opción | Por qué |\n|------|-------------|--------|\n| **Refactor de función** | Cursor Cmd+K | Rápido, inline, diff claro |\n| **Debug de bug complejo** | Claude Code | Mejor razonamiento, más contexto |\n| **Crear feature nueva** | Claude Code | Puede crear/archivos/configurar |\n| **Corregir typo** | Cursor Cmd+K | Sobrekill usar Claude Code |\n| **Code review** | Claude Code | Mejor análisis crítico |\n| **Documentation** | Claude Code | Mejor generador de docs |\n| **Autocomplete rápido** | Cursor | Más rápido y fluido |\n| **Análisis de architecture** | Claude Code | Claude Opus es mejor razonando |\n\n---\n\n## Sesiones SSH y Persistencia\n\n### El Problema del Desarrollo Remoto\n\n```\nESCENARIO TÍPICO:\n\n1. Te conectas a servidor remoto via SSH\n   ssh user@production-server.com\n\n2. Empiezas a editar archivos\n   vim /app/config.json\n\n3. Cortas la conexión (WiFi se cae, cierras laptop)\n\n4. ¡PERDISTE TODO!\n   - Tu estado de editor\n   - Archivos temporales\n   - Contexto mental\n\n5. Tienes que reconectar y reconstruir contexto\n   ``Perdí 30 minutos de mi vida\" 😭\n```\n\n### Solución 1: VS Code Remote SSH\n\n```bash\n# 1. Instalar VS Code Remote SSH extension\n\n# 2. Configurar SSH hosts\n# File → Preferences → Configure SSH Hosts\n\n# ~/.ssh/config\nHost production\n  HostName production-server.com\n  User ubuntu\n  IdentityFile ~/.ssh/my-key.pem\n\n# 3. Conectar via VS Code\n# Cmd+Shift+P → \"Remote-SSH: Connect to Host\" → production\n\n# Resultado:\n# - VS Code corre como si estuviera local\n# - Persistencia de estado automática\n# - Extensions instaladas en remote\n# - Archivos abiertos se mantienen\n```\n\n**Ventajas**:\n- ✅ Persistencia automática (si cierras VS Code, todo está ahí cuando vuelves)\n- ✅ Extensions corren en el remote (intellisense, linting, etc.)\n- ✅ Terminal integrada en el servidor\n- ✅ Mismo experience que local\n\n**Desventajas**:\n- ❌ Requiere instalación de extensions en remote\n- ❌ Puede ser lento si conexión es lenta\n- ❌ No funciona si server tiene recursos muy limitados\n\n### Solución 2: Tmux + Vim/Nvim\n\n```bash\n# 1. Crear sesión tmux persistente\n\ntmux new -s my-session  # Crear sesión \"my-session\"\n\n# 2. Trabajar normalmente dentro de tmux\nvim app/routes.ts\n# ... edits ...\n\n# 3. Desconectarse SIN cerrar sesión\n# Presiona: Ctrl+B, luego D (detach)\n\n# 4. Reconectarse más tarde (desde otra terminal/computadora)\ntmux attach -t my-session\n\n# Resultado:\n# - Todo está EXACTAMENTE como lo dejaste\n# - Vim con el mismo archivo, mismo cursor\n# - Historial de comandos intacto\n# - Múltiples panes si los tenías\n```\n\n**Ventajas**:\n- ✅ Muy ligero, corre en cualquier server\n- ✅ Persistencia garantizada (sobrevive reinicios de tu laptop)\n- ✅ Puedes attach desde múltiples lugares simultáneamente\n- ✅ No requiere instalación en server (solo tmux)\n\n**Desventajas**:\n- ❌ Curve de aprendizaje (tmux keybindings no son intuitivos)\n- ❌ No es tan user-friendly como VS Code\n- ❌ Sin intellisense ni extensions modernas\n\n### Comparativa: Persistencia\n\n| Aspecto | VS Code Remote SSH | Tmux + Vim |\n|---------|-------------------|-----------|\n| **Persistencia de editor** | ✅ Automática | ✅ Automática (en sesión tmux) |\n| **Persistencia de terminal** | ✅ Sí | ✅ Sí |\n| **Recovery de desconexión** | Reconectar VS Code | tmux attach |\n| **Múltiples locations** | ⚠️ Complicado | ✅ Fácil (attach desde cualquier lado) |\n| **Intellisense** | ✅ Full (TypeScript) | ❌ Ninguno (vim puro) |\n| **Uso de recursos del server** | Alto (VS Code server) | Bajo (tmux es ligero) |\n\n---\n\n## Problemas de \"Terminal Illusion\"\n\n### ¿Qué es Terminal Illusion?\n\n```\n┌────────────────────────────────────────────────────────┐\n│           TERMINAL ILLUSION                            │\n├────────────────────────────────────────────────────────┤\n│                                                        │\n│  Tú crees que:                                         │\n│  \"El código está corriendo en mi laptop\"              │\n│                                                        │\n│  Realidad:                                             │\n│  \"Estás conectado a un server remoto via SSH\"         │\n│  \"El código corre en el server, no en tu laptop\"       │\n│                                                        │\n│  Problema:                                             │\n│  - Haces cambios en local                             │\n│  - No se reflejan en remote (o viceversa)             │\n│  - Confusión sobre dónde está corriendo qué           │\n│                                                        │\n└────────────────────────────────────────────────────────┘\n```\n\n### Síntomas de Terminal Illusion\n\n```\n❌ SÍNTOMA 1: \"Funciona en local, no en prod\"\n\n- Editaste archivo en local\n- Hices deploy\n- Cambios no se reflejan\n- Razón: Editaste versión local, no estás sincronizado con remote\n\n❌ SÍNTOMA 2: \"¿Por qué localhost no funciona?\"\n\n- Estás conectado a server via SSH\n- Tratas de abrir localhost:3000 en tu navegador\n- No carga\n- Razón: localhost del server ≠ localhost de tu laptop\n\n❌ SÍNTOMA 3: \"Perdí mis cambios\"\n\n- Editaste archivo en sesión SSH\n- Cerraste conexión sin guardar\n- Cambios desaparecieron\n- Razón: Editaste en filesystem temporal de remote\n```\n\n### Prevención de Terminal Illusion\n\n```bash\n# TÉCNICA 1: Prompt de SSH claro\n\n# ~/.bashrc o ~/.zshrc\n\nfunction ssh_prompt() {\n  if [[ -n \"$SSH_CONNECTION\" ]]; then\n    # Estás en sesión SSH\n    export PS1=\"\\[\\033[01;31m\\]\\u@\\h\\[\\033[00m\\]:\\w\\$ \"\n    # Rojo indica REMOTO, peligro\n  else\n    # Estás en local\n    export PS1=\"\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\w\\$ \"\n    # Verde indica LOCAL, seguro\n  fi\n}\n\nssh_prompt\n\n# Resultado:\n# user@laptop ~/project $  # VERDE = Local\n# user@server ~/project $  # ROJO = Remote\n```\n\n```bash\n# TÉCNICA 2: Comando de verificación de ubicación\n\nalias whereami='echo \"Hostname: $(hostname) | IP: $(hostname -I | awk \\'{print $1}\\')\"'\n\n# Úsalo cuando dudes:\n# $ whereami\n# Hostname: laurences-macbook | IP: 192.168.1.5\n# → Estás en local\n\n# $ whereami\n# Hostname: production-server | IP: 10.0.1.50\n# → Estás en production, CUIDADO\n```\n\n```bash\n# TÉCNICA 3: Archivo .hostname en cada proyecto\n\n# En cada proyecto, crea archivo que identifique ambiente\n\n# local/.hostname\necho \"local\" > .hostname\n\n# production/.hostname  \necho \"production\" > .hostname\n\n# En tu prompt, muestra este archivo\nfunction show_env() {\n  if [[ -f .hostname ]]; then\n    local env=$(cat .hostname)\n    echo \"[$env] \"\n  fi\n}\n\nexport PS1=\"$(show_env)\\u@\\h:\\w\\$ \"\n\n# Resultado:\n# [local] user@laptop:~/project $  \n# [production] user@server:~/project $  # ¡ALERTA ROJA!\n```\n\n---\n\n## Cuando Restart No Ayuda\n\n### El Bug \"Persistent State\"\n\n```\nESCENARIO:\n\n1. Tienes un bug extraño\n2. Restart el dev server (npm run dev)\n3. Bug persiste\n4. Restart tu laptop\n5. Bug AÚN persiste\n6. Desesperación 😱\n```\n\n### Causas Comunes de Bugs Persistentes\n\n```\n┌────────────────────────────────────────────────────────────┐\n│        BUGS SOBREVIVEN RESTARTS (Y CÓMO FIJARLOS)          │\n├────────────────────────────────────────────────────────────┤\n│                                                            │\n│  1. BUILD ARTIFACTS                                     │\n│     - next/, .next/, dist/ contienen código compilado   │\n│     - Restart no los regenera si no haces clean build   │\n│     → FIX: rm -rf .next && npm run build                │\n│                                                            │\n│  2. CACHE DE NODE MODULES                              │\n│     - node_modules/.cache contiene builds cacheados     │\n│     - Corrupción de cache causa bugs misteriosos        │\n│     → FIX: rm -rf node_modules && npm install            │\n│                                                            │\n│  3. ENVIRONMENT VARIABLES PERSISTENTES                  │\n│     - .env.local no se actualiza en runtime            │\n│     - Changes requieren restart del proceso             │\n│     → FIX: Asegúrate que restart recargó .env            │\n│                                                            │\n│  4. DATABASE STATE                                     │\n│     - Datos en DB persisten entre restarts              │\n│     - Bugs pueden estar en datos, no en código          │\n│     → FIX: DROP DATABASE y recreate, o fix data          │\n│                                                            │\n│  5. BROWSER CACHE                                      │\n│     - Browser cachea JS, CSS, responses                │\n│     - Changes no se reflejan si cache es agresivo       │\n│     → FIX: Hard refresh (Cmd+Shift+R) o incognito mode   │\n│                                                            │\n│  6. SESSION STORAGE / LOCAL STORAGE                    │\n│     - Auth tokens, settings persisten en browser        │\n│     - Stale tokens causan errores de auth               │\n│     → FIX: Clear storage en DevTools                     │\n│                                                            │\n│  7. CORS / HEADERS CACHEADOS                            │\n│     - Browser cachea CORS preflight responses           │\n│     - Changes en CORS no se reflejan                    │\n│     → FIX: Disable cache en DevTools Network tab        │\n│                                                            │\n│  8. CONTENT DELIVERY NETWORK (CDN)                     │\n│     - Vercel/Cloudflare cachean páginas                 │\n│     - Changes pueden tardar hasta 24h en propagar       │\n│     → FIX: Purge cache en dashboard de CDN               │\n│                                                            │\n└────────────────────────────────────────────────────────────┘\n```\n\n### Debugging Checklist para Bugs Persistentes\n\n```markdown\n## Checklist: Bug Sobrevive Restart\n\n- [ ] **Verificaste que el server realmente restarteó**\n  - ¿Ves \"Server ready\" en logs?\n  - ¿Puerto cambió? (puede indicar proceso zombie)\n  \n- [ ] **Limpiaste build artifacts**\n  - rm -rf .next dist build\n  - npm run build (fresh build)\n  \n- [ ] **Limpiaste cache de node modules**\n  - rm -rf node_modules/.cache\n  - O rm -rf node_modules && npm install (nuclear option)\n  \n- [ ] **Verificaste environment variables**\n  - echo $MY_VAR (¿tiene el valor correcto?)\n  - ¿Restarteaste DESPUÉS de cambiar .env?\n  \n- [ ] **Limpiaste estado de browser**\n  - Hard refresh (Cmd+Shift+R)\n  - Incognito mode (para descartar extensions)\n  - Clear storage en DevTools\n  \n- [ ] **Verificaste estado de database**\n  - ¿Los datos en DB son consistentes?\n  - ¿Hay rows corruptas o inconsistentes?\n  \n- [ ] **Verificaste CDN cache**\n  - ¿Estás viendo versión cacheada de CDN?\n  - Purge cache si applicable\n  \n- [ ] **Verificaste CORS/headers**\n  - ¿Browser está cacheando CORS preflight?\n  - Disable cache en DevTools\n```\n\n---\n\n## Ejercicio: Diagnostica un \"Working Locally\" Failure\n\n### Escenario\n\n```\nREPORT DE BUG:\n\n\"El feature de comentarios funciona perfectamente en mi máquina local,\n pero en producción (deploy de Vercel) los comentarios no se guardan.\n\nHe intentado:\n- Restart el dev server (funciona en local)\n- Limpiar cache del browser (no ayudó)\n- Revisar logs de Vercel (no hay errores)\n\n¿Qué puede ser?\"\n```\n\n### Tu Tarea: Diagnóstico Completo\n\nUsa el framework que has aprendido para diagnosticar:\n\n```markdown\n## Diagnóstico: \"Working Locally\" Failure\n\n### Paso 1: Clasificación del Bug\n\n¿Es bug de código, infra, o config?\n- Diagnóstico: ___\n- Justificación: ___\n\n### Paso 2: Checklist de Verificación\n\n- [ ] ¿Build artifacts están limpios?\n  - Acción: ___\n  \n- [ ] ¿Environment variables están correctas?\n  - Qué variables revisar: ___\n  \n- [ ] ¿Database es accesible desde production?\n  - Cómo verificar: ___\n  \n- [ ] ¿CORS está configurado para production domain?\n  - Qué revisar: ___\n  \n- [ ] ¿API routes están deployadas correctamente?\n  - Cómo verificar: ___\n\n### Paso 3: Hipótesis Principales\n\nHipótesis 1: ___\n- Cómo probar: ___\n- Si es correcta, fix es: ___\n\nHipótesis 2: ___\n- Cómo probar: ___\n- Si es correcta, fix es: ___\n\n### Paso 4: Plan de Debugging\n\n1. Primero, verificar: ___\n2. Luego, probar: ___\n3. Finalmente, si todo lo anterior falla: ___\n```\n\n**Escribe tu diagnóstico completo antes de continuar.**\n\n---\n\n## Checklist: IDEs & Execution\n\nAntes de finalizar, verifica:\n\n- [ ] Entiendo las diferencias entre **Cursor, Claude Code, y VS Code puro**\n- [ ] Sé cuándo usar cada herramienta para máxima productividad\n- [ ] Puedo configurar **sesiones SSH persistentes** (VS Code Remote o tmux)\n- [ ] Reconozco y prevengo **\"terminal illusion\"**\n- [ ] Tengo un **checklist** para bugs que sobreviven restarts\n- [ ] Puedo diagnosticar sistemáticamente **\"working locally\" failures**\n\n---\n\n## Resumen: IDEs & Execution\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Cursor para edits rápidos** | Cmd+K para refactor inline, muy rápido |\n| **Claude Code para tareas complejas** | /prompt para debugging, architecture, multi-file |\n| **SSH persistente** | Uso VS Code Remote o tmux para no perder trabajo |\n| **Anti terminal illusion** | Siempre sé dónde estoy (local vs remote) |\n| **Debugging sistemático** | Tengo checklist para bugs persistentes |\n\n**Checkpoint final**: ¿Puedes diagnosticar un \"works on my machine\" bug sin adivinar?\n\nEsta skill te salva de horas de frustración y \"it works on my machine\" excuses.",
      "content_url": null,
      "sort_order": 6,
      "duration_minutes": 25
    },
    {
      "title": "Modulo 7: Production Discipline",
      "content_type": "markdown",
      "content": "# Módulo 7: Production Discipline\n\n## La Última Frontera: Código en Producción\n\nTodo lo que has aprendido hasta ahora es **teoría**. Production discipline es **práctica**: cómo escribir código que **no se rompe en producción**.\n\nEn vibe coding, esta disciplina es MÁS importante porque:\n- La IA puede generar código rápido\n- Pero si ese código no es production-ready, **es inútil**\n\n---\n\n## Ley de Serialización\n\n### ¿Qué es Serialización?\n\n**Serialización** = convertir objetos en un formato que puede ser transmitido o almacenado.\n\n```\nOBJETO EN MEMORIA → SERIALIZACIÓN → FORMATO TRANSMITIBLE (JSON, XML)\nFORMATO TRANSMITIBLE → DESERIALIZACIÓN → OBJETO EN MEMORIA\n```\n\n### La Ley de Serialización\n\n```\n┌──────────────────────────────────────────────────────────┐\n│              LEY DE SERIALIZACIÓN                        │\n├──────────────────────────────────────────────────────────┤\n│                                                          │\n│  \"TODO lo que cruza fronteras de tu sistema             │\n│   (API, DB, cache, queue) debe ser SERIALIZABLE.\"       │\n│                                                          │\n│  Si NO es serializable, eventualmente FALLARÁ en prod.  │\n│                                                          │\n└──────────────────────────────────────────────────────────┘\n\n⚠️ ESTAS COSAS NO SON SERIALIZABLES:\n\n- Functions (no puedes enviar funciones por JSON)\n- Classes (las instancias pierden métodos al serializar)\n- Dates (JSON las convierte a strings)\n- undefined (JSON lo convierte a null)\n- Circular references (causan errors en JSON.stringify)\n- Map/Set (se convierten a objetos vacíos en JSON)\n```\n\n### Ejemplo: The Date Trap\n\n```typescript\n// ❌ PROBLEMA: Dates no se serializan correctamente\n\ninterface User {\n  id: string\n  name: string\n  createdAt: Date  // ← NO serializa bien\n}\n\nconst user: User = {\n  id: '123',\n  name: 'Alice',\n  createdAt: new Date('2024-01-15')\n}\n\n// Serializar (enviar a API)\nconst json = JSON.stringify(user)\n// Resultado: '{\"id\":\"123\",\"name\":\"Alice\",\"createdAt\":\"2024-01-15T00:00:00.000Z\"}'\n// ↑ createdAt ahora es STRING, no Date\n\n// Deserializar (recibir de API)\nconst parsed = JSON.parse(json)\n// parsed.createdAt es STRING, no Date\n// parsed.createdAt instanceof Date → false\n// parsed.createdAt.getFullYear() → TypeError!\n```\n\n**Fix: DTOs (Data Transfer Objects)**\n\n```typescript\n// ✅ SOLUCIÓN: DTO con strings, conversion en frontera\n\n// DTO para API (serializable)\ninterface UserDTO {\n  id: string\n  name: string\n  created_at: string  // ISO 8601 string\n}\n\n// Domain model (interna, no cruza fronteras)\ninterface User {\n  id: string\n  name: string\n  createdAt: Date\n}\n\n// Convertir Domain → DTO\nfunction toDTO(user: User): UserDTO {\n  return {\n    id: user.id,\n    name: user.name,\n    created_at: user.createdAt.toISOString()  // Date → String\n  }\n}\n\n// Convertir DTO → Domain\nfunction fromDTO(dto: UserDTO): User {\n  return {\n    id: dto.id,\n    name: dto.name,\n    createdAt: new Date(dto.created_at)  // String → Date\n  }\n}\n\n// Ahora puedes serializar sin problemas\nconst user: User = {\n  id: '123',\n  name: 'Alice',\n  createdAt: new Date('2024-01-15')\n}\n\nconst dto = toDTO(user)  // ← Serializable\nconst json = JSON.stringify(dto)  // ← Siempre funciona\nconst parsedDTO = JSON.parse(json)  // ← Type-safe\nconst parsedUser = fromDTO(parsedDTO)  // ← Date restaurado correctamente\n```\n\n### Tabla de Serializabilidad\n\n| Tipo TypeScript | ¿Serializable en JSON? | Notas |\n|-----------------|------------------------|-------|\n| **string, number, boolean** | ✅ Sí | Perfecto |\n| **null** | ✅ Sí | Perfecto |\n| **Array (de tipos primitivos)** | ✅ Sí | Perfecto |\n| **Object (plain)** | ✅ Sí | Perfecto |\n| **Date** | ⚠️ Parcial | Se convierte a string ISO |\n| **undefined** | ❌ No | Se convierte a null (pérdida de info) |\n| **Function** | ❌ No | Se elimina en stringify |\n| **Class instance** | ⚠️ Parcial | Pierde métodos, solo mantiene propiedades |\n| **Map, Set** | ❌ No | Se convierte a {} vacío |\n| **Circular ref** | ❌ No | Causa error en stringify |\n| **BigInt** | ❌ No | Causa error en stringify |\n\n---\n\n## No `as any` Sin Confesión\n\n### La Trampa de `as any`\n\n```\n❌ EL PECADO DE `as any`:\n\nconst data = await fetch('/api/users').then(r => r.json())\n\nconst users = data as any  // ← MAL, muy mal\n\nusers.map(u => ...)  // TypeScript cree que esto es seguro\n// Pero en runtime, si data no es un array, esto fallará\n```\n\n### La Regla\n\n```\n┌──────────────────────────────────────────────────────────┐\n│           REGLA: NO `as any` SIN CONFESIÓN              │\n├──────────────────────────────────────────────────────────┤\n│                                                          │\n│  Si usas `as any`, DEBES:                               │\n│  1. Explicar en comentario POR QUÉ es necesario          │\n│  2. Agregar un TODO con cómo arreglarlo                  │\n│  3. Agregar validación en runtime si es crítico          │\n│                                                          │\n│  Si NO puedes hacer lo anterior, NO uses `as any`.      │\n│                                                          │\n└──────────────────────────────────────────────────────────┘\n```\n\n### Ejemplo: Con Confesión\n\n```typescript\n// ❌ MAL: as any sin explicación\nconst config = loadConfig() as any\nconst apiKey = config.apiKey\n\n// ✅ BIEN: as any con confesión\n/**\n * TODO: Migrate to typed config loader\n * \n * CONFESIÓN: Usamos `as any` aquí porque loadConfig() returns `unknown`\n * y el schema es demasiado complejo para tipar ahora (50+ propiedades).\n * \n * Riesgo mitigado:\n * - Validamos que apiKey existe antes de usarlo\n * - Si es undefined, lanzamos error claro\n * \n * Fix plan:\n * - Migrar a schema validation con Zod (ticket #456)\n * - Remover este `as any` cuando schema esté completo\n */\nconst config = loadConfig() as any\n\n// Validación en runtime\nif (typeof config.apiKey !== 'string') {\n  throw new Error(\n    'Configuration error: apiKey must be a string. ' +\n    'Check your .env file.'\n  )\n}\n\nconst apiKey = config.apiKey\n```\n\n### Alternativas a `as any`\n\n```typescript\n// OPCIÓN 1: Validación con Zod\n\nimport { z } from 'zod'\n\nconst ConfigSchema = z.object({\n  apiKey: z.string(),\n  port: z.number().int().positive(),\n  debug: z.boolean().default(false)\n})\n\nconst config = ConfigSchema.parse(loadConfig())\n// ↑ `config` está correctamente tipado, sin `as any`\n\n// OPCIÓN 2: Type guards\n\ninterface Config {\n  apiKey: string\n  port: number\n  debug: boolean\n}\n\nfunction isConfig(data: unknown): data is Config {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'apiKey' in data &&\n    typeof data.apiKey === 'string' &&\n    'port' in data &&\n    typeof data.port === 'number' &&\n    'debug' in data &&\n    typeof data.debug === 'boolean'\n  )\n}\n\nconst rawData = loadConfig()\n\nif (!isConfig(rawData)) {\n  throw new Error('Invalid config structure')\n}\n\n// `rawData` ahora es de tipo `Config`, sin `as any`\nconst config: Config = rawData\n\n// OPCIÓN 3: Type assertion con tipo específico (menos peor que `as any`)\n\nconst config = loadConfig() as Partial<Config>\n// ↑ TypeScript sabe que algunas propiedades pueden ser undefined\n\nif (!config.apiKey) {\n  throw new Error('apiKey is required')\n}\n```\n\n---\n\n## DTO Discipline\n\n### ¿Qué es un DTO?\n\n**DTO (Data Transfer Object)** = Objeto diseñado específicamente para **transferir datos** entre capas de tu sistema.\n\n```\n┌────────────────────────────────────────────────────────────┐\n│                    ARQUITECTURA DTO                        │\n├────────────────────────────────────────────────────────────┤\n│                                                            │\n│  LAYER                    TIPO DE DATO                    │\n│                                                            │\n│  Database         ←→  DB Entities (ORM models)            │\n│       │                                                   │\n│       │  convert                                        │\n│       ↓                                                   │\n│  API Layer        ←→  DTOs (serializable, type-safe)      │\n│       │                                                   │\n│       │  convert                                        │\n│       ↓                                                   │\n│  Frontend         ←→  View Models (UI-specific)          │\n│                                                            │\n│  Cada capa tiene SU PROPIO tipo de dato.                 │\n│  Nunca compartas tipos entre capas.                      │\n│                                                            │\n└────────────────────────────────────────────────────────────┘\n```\n\n### DTOs en Práctica\n\n```typescript\n// ============================================\n// CAPA 1: Database Entities (Interna)\n// ============================================\n\n// Esto NO sale de la capa de database\ninterface UserEntity {\n  id: string\n  email: string\n  password_hash: string  // ← Sensible, nunca viaja en API\n  created_at: Date\n  updated_at: Date\n}\n\n// ============================================\n// CAPA 2: DTOs (Frontera de API)\n// ============================================\n\n// DTO para respuesta de API (pública)\ninterface UserResponseDTO {\n  id: string\n  email: string\n  created_at: string  // ISO 8601, no Date\n}\n\n// DTO para crear usuario (request)\ninterface CreateUserDTO {\n  email: string\n  password: string  // Password viaja solo al crear\n}\n\n// ============================================\n// CAPA 3: View Models (Frontend)\n// ============================================\n\n// View model para UI de usuario\ninterface UserViewModel {\n  id: string\n  email: string\n  createdAt: Date  // ← Date está bien en frontend\n  memberSince: string  // Formato para display: \"Jan 2024\"\n}\n\n// ============================================\n// CONVERSIONES (Leyes de frontera)\n// ============================================\n\n// Entity → DTO\nfunction entityToResponseDTO(entity: UserEntity): UserResponseDTO {\n  return {\n    id: entity.id,\n    email: entity.email,\n    created_at: entity.created_at.toISOString()  // Date → String\n  }\n}\n\n// DTO → Entity\nfunction dtoToEntity(dto: CreateUserDTO): Omit<UserEntity, 'id' | 'created_at' | 'updated_at'> {\n  return {\n    email: dto.email,\n    password_hash: hashPassword(dto.password)  // Hash ANTES de guardar\n  }\n}\n\n// DTO → View Model\nfunction dtoToViewModel(dto: UserResponseDTO): UserViewModel {\n  const createdAt = new Date(dto.created_at)\n  \n  return {\n    id: dto.id,\n    email: dto.email,\n    createdAt: createdAt,  // String → Date\n    memberSince: createdAt.toLocaleDateString('en-US', {\n      month: 'short',\n      year: 'numeric'\n    })\n  }\n}\n\n// ============================================\n// USO EN API ROUTE\n// ============================================\n\n// app/api/users/route.ts\nexport async function GET() {\n  // 1. Fetch from DB (returns Entity)\n  const entities: UserEntity[] = await db.users.findMany()\n  \n  // 2. Convert to DTO\n  const dtos: UserResponseDTO[] = entities.map(entityToResponseDTO)\n  \n  // 3. Return DTO (never Entity!)\n  return Response.json(dtos)\n}\n```\n\n### Reglas de DTO\n\n```\n┌──────────────────────────────────────────────────────────┐\n│                  REGLAS DE DTO                            │\n├──────────────────────────────────────────────────────────┤\n│                                                          │\n│  1. DTOs SON INMUTABLE                                   │\n│     - Usa `readonly` propiedades                         │\n│     - O usa TypeScript `readonly` o Object.freeze()      │\n│                                                          │\n│  2. DTOs SON SERIALIZABLES                               │\n│     - Solo tipos primitivos + arrays + objects           │\n│     - NO Dates, functions, Classes                       │\n│                                                          │\n│  3. DTOs TIENEN VALIDACIÓN                               │\n│     - Usa Zod o similar en la frontera                   │\n│     - Nunca confíes en datos externos sin validar       │\n│                                                          │\n│  4. DTOs NO TIENEN LÓGICA DE NEGOCIO                     │\n│     - Son contenedores de datos puro                     │\n│     - La lógica va en Services o Domain models           │\n│                                                          │\n│  5. UN DTO POR PROPÓSITO                                  │\n│     - CreateUserDTO ≠ UserResponseDTO                    │\n│     - No reuses el mismo DTO para todo                   │\n│                                                          │\n└──────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Build-time Paranoia\n\n### ¿Qué es Build-time Paranoia?\n\n**Build-time paranoia** = **asumir que todo puede fallar en build time**, y validar exhaustivamente antes de llegar a runtime.\n\n```\n┌──────────────────────────────────────────────────────────┐\n│             BUILD-TIME PARANOIA                          │\n├──────────────────────────────────────────────────────────┤\n│                                                          │\n│  Filosofía:                                              │\n│  \"Prefiero que falle el BUILD que falle en PRODUCCIÓN\"   │\n│                                                          │\n│  Strategia:                                             │\n│  - Validar TODO en build time                           │\n│  - Usar TypeScript al máximo                             │\n│  - Nunca confiar en runtime validations                  │\n│                                                          │\n└──────────────────────────────────────────────────────────┘\n```\n\n### Técnicas de Build-time Paranoia\n\n#### 1. Type Guards para Validaciones\n\n```typescript\n// ❌ MAL: Validación en runtime sin type safety\n\nfunction getConfigValue(key: string): any {\n  return config[key]\n}\n\nconst apiKey = getConfigValue('apiKey')\n// ↑ TypeScript no sabe que esto es string\n\n// ✅ BIEN: Type guard + type narrowing\n\ninterface Config {\n  apiKey: string\n  port: number\n  debug: boolean\n}\n\nfunction getConfigValue<K extends keyof Config>(key: K): Config[K] {\n  const value = config[key]\n  \n  if (value === undefined) {\n    throw new Error(`Config key \"${key}\" is missing`)\n  }\n  \n  return value\n}\n\n// TypeScript ahora sabe que esto es string\nconst apiKey: string = getConfigValue('apiKey')\nconst port: number = getConfigValue('port')\n```\n\n#### 2. Template Literal Types para Validación\n\n```typescript\n// ❌ MAL: Strings no validados\n\ntype LogLevel = string\n\nfunction log(level: LogLevel, message: string) {\n  console.log(`[${level}] ${message}`)\n}\n\nlog('error', 'Something failed')  // OK\nlog('ERORR', 'Something failed')  // Typo, pero TypeScript no lo detecta\n\n// ✅ BIEN: Template literal types\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\nfunction log(level: LogLevel, message: string) {\n  console.log(`[${level}] ${message}`)\n}\n\nlog('error', 'Something failed')  // OK\nlog('ERORR', 'Something failed')  // ❌ TypeScript error: Type '\"ERORR\"' is not assignable to type 'LogLevel'\n```\n\n#### 3. Const Assertions para Enums\n\n```typescript\n// ❌ MAL: Enum sin type safety\n\nconst ROLES = {\n  ADMIN: 'admin',\n  USER: 'user',\n  GUEST: 'guest'\n}\n\nfunction hasRole(role: string) {\n  return user.roles.includes(role)\n}\n\nhasRole('admin')  // OK\nhasRole('superadmin')  // ❌ Typo, pero TypeScript no lo detecta\n\n// ✅ BIEN: Const assertion + type\n\nconst ROLES = {\n  ADMIN: 'admin',\n  USER: 'user',\n  GUEST: 'guest'\n} as const  // ← Crea tipo literal\n\ntype Role = typeof ROLES[keyof typeof ROLES]\n// ↑ Type es 'admin' | 'user' | 'guest'\n\nfunction hasRole(role: Role) {\n  return user.roles.includes(role)\n}\n\nhasRole('admin')  // OK\nhasRole('superadmin')  // ❌ TypeScript error\n```\n\n#### 4. Exhaustiveness Checks\n\n```typescript\n// ✅ BIEN: Exhaustiveness check para unions\n\ntype Action =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n\nfunction reducer(action: Action) {\n  switch (action.type) {\n    case 'fetch':\n      return { loading: true }\n    case 'success':\n      return { loading: false, data: action.data }\n    case 'error':\n      return { loading: false, error: action.error }\n    default:\n      // ↑ Si añades un nuevo caso a Action y olvidas actualizar aquí,\n      // TypeScript dará error aquí:\n      // \"Type 'XXX' is not assignable to type 'never'\"\n      const _exhaustiveCheck: never = action\n      return _exhaustiveCheck\n  }\n}\n```\n\n---\n\n## Ejercicio Final: Auditoría de Subsistema\n\n### Instrucciones\n```\nAUDITORÍA: \"Report Only Facts\"\n\nTu tarea es auditar un subsistema y reportar SOLO HECHOS.\n\nNO:\n- Opiniones (\"este código es malo\")\n- Especulaciones (\"probablemente esto cause problemas\")\n- Soluciones (\"deberíamos refactorizar esto\")\n\nSÍ:\n- Hechos observables (\"la función X usa `as any` sin validación\")\n- Evidencia (\"línea 45, archivo user.ts\")\n- Impacto medible (\"esto puede causar runtime error si data es undefined\")\n```\n\n### Código a Auditar\n\n```typescript\n// lib/user-service.ts\n\ninterface User {\n  id: string\n  name: string\n  email: string\n  role: 'admin' | 'user'\n  preferences: UserPreferences\n}\n\ninterface UserPreferences {\n  theme: 'light' | 'dark'\n  notifications: boolean\n}\n\n// Buscar usuario por ID\nexport async function findUser(id: string): Promise<User | null> {\n  const response = await fetch(`/api/users/${id}`)\n  const data = await response.json() as any  // ← LINE 20\n  \n  if (!data) {\n    return null\n  }\n  \n  return data  // ← LINE 27\n}\n\n// Crear usuario\nexport async function createUser(userData: any): Promise<User> {  // ← LINE 32\n  const response = await fetch('/api/users', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(userData)\n  })\n  \n  const user = await response.json() as User  // ← LINE 40\n  return user\n}\n\n// Actualizar usuario\nexport async function updateUser(id: string, updates: any): Promise<User> {  // ← LINE 44\n  const response = await fetch(`/api/users/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates)\n  })\n  \n  const data = await response.json()\n  return data  // ← LINE 53\n}\n\n// Eliminar usuario\nexport async function deleteUser(id: string): Promise<void> {\n  await fetch(`/api/users/${id}`, {\n    method: 'DELETE'\n  })\n}\n\n// Obtener preferencias de usuario\nexport function getUserPreferences(user: User): UserPreferences {\n  return user.preferences  // ← LINE 65\n}\n\n// Formatear usuario para display\nexport function formatUserForDisplay(user: any): string {  // ← LINE 69\n  return `${user.name} (${user.email})`\n}\n```\n\n### Template de Reporte\n\n```markdown\n# Auditoría: user-service.ts\n\nFecha: ___\nAuditor: ___\n\n## Resumen Ejecutivo\n\nNúmero de problemas encontrados: ___\nProblemas críticos: ___\nProblemas mayores: ___\nProblemas menores: ___\n\n---\n\n## Problemas Críticos (Production-blocking)\n\n### 1. [Título del problema]\n\n**Hecho**: ___\n- Archivo: ___\n- Línea: ___\n- Código: ___\n\n**Impacto**: ___\n- ¿Qué puede causar en producción? ___\n\n**Evidencia**: ___\n\n---\n\n## Problemas Mayores (Deberían arreglarse pronto)\n\n### 1. [Título del problema]\n\n**Hecho**: ___\n\n**Impacto**: ___\n\n**Evidencia**: ___\n\n---\n\n## Problemas Menores (Nice-to-have fixes)\n\n### 1. [Título del problema]\n\n**Hecho**: ___\n\n**Impacto**: ___\n\n**Evidencia**: ___\n\n---\n\n## Observaciones Generales\n\n- [Hechos adicionales, no necesariamente problemas]\n\n---\n\n## Recomendaciones (Opcional)\n\n*Nota: Estas son sugerencias, no parte de la auditoría de hechos.*\n\n- ___\n```\n\n**Completa tu auditoría antes de continuar.**\n\n---\n\n## Checklist: Production Discipline\n\nAntes de finalizar, verifica:\n\n- [ ] Entiendo la **ley de serialización** y sus implicaciones\n- [ ] Nunca uso `as any` sin **confesión y mitigación**\n- [ ] Uso **DTOs** para transferir datos entre capas\n- [ ] Practico **build-time paranoia** con type guards y assertions\n- [ ] Puedo auditar código y reportar **solo hechos, no opiniones**\n\n---\n\n## Resumen: Production Discipline\n\n| Concepto Clave | Tu Compromiso |\n|----------------|---------------|\n| **Ley de serialización** | Todo lo que cruza fronteras debe ser serializable |\n| **Sin `as any` sin confesión** | Documento por qué es necesario y cómo fixear |\n| **DTOs obligatorios** | Separo tipos entre DB, API, y frontend |\n| **Build-time paranoia** | Valido todo en compilación, no runtime |\n| **Auditoría de hechos** | Reporto problemas observables, no opiniones |\n\n**Checkpoint final**: ¿Puedes escribir código que esté garantizado a no fallar en producción?\n\nEsta disciplina es lo que separa a los vibe coders de los developers que \"usan IA\".",
      "content_url": null,
      "sort_order": 7,
      "duration_minutes": 25
    },
    {
      "title": "Modulo 8: Certificacion",
      "content_type": "markdown",
      "content": "# Módulo 8: Certificación 🏆\n\n> **¡Felicitaciones por llegar hasta aquí!**\n> \n> Este módulo final valida tu conocimiento y te otorga la certificación oficial.\n\n---\n\n## Badge: Fyves Vibe Coder - Nivel 1\n\nAl completar este curso y aprobar la certificación, recibirás:\n\n```\n╔═══════════════════════════════════════════════════════════════╗\n║                                                               ║\n║     ⭐ FYVES VIBE CODER - NIVEL 1 ⭐                          ║\n║                                                               ║\n║     Certified in:                                             ║\n║     ✓ Multi-agent orchestration                              ║\n║     ✓ AI-augmented development workflows                     ║\n║     ✓ Production-ready code discipline                       ║\n║     ✓ Infrastructure awareness                               ║\n║                                                               ║\n║     Issued: [DATE]                                           ║\n║     Valid forever (no expiration)                            ║\n║                                                               ║\n╚═══════════════════════════════════════════════════════════════╝\n```\n\n### Privileges de Certificación\n\n```\n✅ CON CERTIFICACIÓN:\n\n1. Accesso a repos \"sensitive\"\n   - Puedes trabajar en proyectos production-critical\n   - Tienes permisos de deployment\n   - Acceso a documentation avanzada\n\n2. Reconocimiento en equipo\n   - Tu badge es visible en tu perfil de equipo\n   - Prioridad para code reviews técnicos\n   - Mentoría de vibe coders junior\n\n3. Credibilidad técnica\n   - Puedes auditar código de otros\n   - Tu opinión en architecture discussions tiene peso\n   - Puedes representar a Fyves en proyectos externos\n\n❌ SIN CERTIFICACIÓN:\n\n- Solo puedes trabajar en repos non-sensitive\n- No tienes permisos de deployment\n- Tu código requiere review doble\n```\n\n---\n\n## Requisitos de Certificación\n\n### Requisito 1: 100% de Secciones Completadas\n\n```\nCHECKLIST DE COMPLECIÓN:\n\nMódulo 0: Orientación\n- [ ] Leído completamente\n- [ ] Entendido concepto de \"IA explora, humanos deciden\"\n- [ ] Checklist de orientación completado\n\nMódulo 1: The Vibe Shift\n- [ ] Leído completamente\n- [ ] Ejercicio de reescritura de plan completado\n- [ ] Entendida diferencia entre control y orquestación\n\nMódulo 2: AI Stack Reality\n- [ ] Leído completamente\n- [ ] Ejercicio de elegir modelo WRONG completado\n- [ ] Entendidas diferencias entre Claude Opus y GLM 4.7\n\nMódulo 3: Prompts as Architecture\n- [ ] Leído completamente\n- [ ] Ejercicio de prompt estricto completado\n- [ ] Entendidas las 4 políticas de Ralph (STOP, TRUTH, FORMAT, SCOPE)\n\nMódulo 4: Multi-Agent Command\n- [ ] Leído completamente\n- [ ] Ejercicio de council design completado\n- [ ] Entendidos patrones de arbitraje\n\nMódulo 5: Infrastructure Awareness\n- [ ] Leído completamente\n- [ ] Ejercicio de diagnóstico completado\n- [ ] Entendida diferencia entre bugs de código, infra, y config\n\nMódulo 6: IDEs & Execution\n- [ ] Leído completamente\n- [ ] Ejercicio de \"working locally\" diagnostic completado\n- [ ] Entendidas diferencias entre Cursor, Claude Code, VS Code\n\nMódulo 7: Production Discipline\n- [ ] Leído completamente\n- [ ] Ejercicio de auditoría completado\n- [ ] Entendida ley de serialización y DTOs\n\nMódulo 8: Certificación\n- [ ] Examen final aprobado (este módulo)\n```\n\n### Requisito 2: Todos los Checkpoints Aprobados\n\n```\nCHECKPOINTS:\n\nMódulo 0:\n☐ ¿Entiendes la diferencia entre \"IA decide\" y \"IA explora\"?\n☐ ¿Por qué debes escribir código antes de prompts?\n☐ ¿Qué hace que un componente sea \"vibe-ready\"?\n☐ ¿Por qué el determinismo es más importante que la elegancia?\n\nMódulo 1:\n☐ ¿Estás listo para dejar ir el control total?\n☐ ¿Puedes reescribir un plan tradicional como agent swarm brief?\n☐ ¿Entiendes el concepto de \"no sé, voy a explorar\"?\n\nMódulo 2:\n☐ ¿Puedes explicar por qué a veces el modelo \"más potente\" es la wrong elección?\n☐ ¿Sabes cuándo usar Claude Opus vs GLM 4.7?\n☐ ¿Puedes calcular el costo de una tarea antes de ejecutarla?\n\nMódulo 3:\n☐ ¿Puedes escribir un prompt que la IA NO pueda malinterpretar?\n☐ ¿Sabes escribir políticas STOP, TRUTH, FORMAT, SCOPE?\n☐ ¿Puedes convertir requisitos vagos en prompts estrictos?\n\nMódulo 4:\n☐ ¿Puedes diseñar un council que resuelva un problema complejo?\n☐ ¿Sabes cuándo dividir en múltiples agentes (3-5 rule)?\n☐ ¿Tienes estrategias para resolver conflictos sin reescribir código?\n\nMódulo 5:\n☐ ¿Puedes ver un error en producción y saber si es código, infra o config?\n☐ ¿Sabes elegir entre Vercel y Netlify?\n☐ ¿Entiendes los cost traps de serverless?\n\nMódulo 6:\n☐ ¿Puedes diagnosticar un \"works on my machine\" bug sin adivinar?\n☐ ¿Sabes cuándo usar Cursor vs Claude Code vs VS Code?\n☐ ¿Tienes un checklist para bugs que sobreviven restarts?\n\nMódulo 7:\n☐ ¿Puedes escribir código que esté garantizado a no fallar en producción?\n☐ ¿Entiendes la ley de serialización?\n☐ ¿Puedes auditar código y reportar solo hechos?\n```\n\n---\n\n## Examen Final de Certificación\n\n### Instrucciones\n\n```\nEXAMEN: FYVES VIBE CODER - NIVEL 1\n\nDuración: 30 minutos\nFormato: Respuestas cortas y código\nPassing score: 80% (8 de 10 correctas)\n\nReglas:\n- Es completamente open-book (puedes revisar los módulos)\n- Pero hazlo de memoria primero, luego verifica\n- Sé específico en tus respuestas (vague answers = incorrect)\n- Para preguntas de código, el código debe compilar\n```\n\n### Preguntas del Examen\n\n```markdown\n## PREGUNTA 1: Fundamentos (2 puntos)\n\nExplica en tus propias palabras la regla de oro del vibe coding:\n\"IA explora, humanos deciden\".\n\n- ¿Qué significa? (1 punto)\n- ¿Por qué es importante? (1 punto)\n\nRespuesta:\n___\n\n---\n\n## PREGUNTA 2: Prompts (2 puntos)\n\nConvierte este requerimiento vago en un prompt estricto usando\npolíticas STOP, TRUTH, y SCOPE.\n\nRequerimiento vago:\n\"Haz que la autenticación funcione\"\n\nTu prompt estricto:\n___\n\n---\n\n## PREGUNTA 3: AI Stack (1 punto)\n\nPara cada tarea, selecciona el modelo apropiado (Claude Opus o GLM 4.7)\ny explica POR QUÉ en una frase.\n\nTarea A: Refactorizar 50 funciones simples de JS a TypeScript\nModelo: ___\nPor qué: ___\n\nTarea B: Diseñar la arquitectura de un sistema de pagos distribuido\nModelo: ___\nPor qué: ___\n\n---\n\n## PREGUNTA 4: Multi-Agent (1 punto)\n\nTienes 5 agentes en un council y están en desacuerdo total.\nNinguno puede convencer a los otros.\n\nDescribe UNA estrategia para resolver el empate sin reescribir código.\n\nEstrategia:\n___\n\n---\n\n## PREGUNTA 5: Infraestructura (1 punto)\n\nUn error ocurre \"solo en producción, nunca en local\".\nEl error es: \"TypeError: Cannot read property 'map' of undefined\"\n\nDiagnostica:\n- ¿Es bug de código, infra, o config? (0.5 puntos)\n- ¿Cuál es tu primera acción para debuggear? (0.5 puntos)\n\nRespuesta:\n___\n\n---\n\n## PREGUNTA 6: Serialización (1 punto)\n\nEste código tiene un problema de serialización. Identifícalo y explícalo.\n\n```typescript\ninterface User {\n  id: string\n  name: string\n  lastLogin: Date\n}\n\nconst user: User = {\n  id: '123',\n  name: 'Alice',\n  lastLogin: new Date()\n}\n\nfetch('/api/users', {\n  method: 'POST',\n  body: JSON.stringify(user)\n})\n```\n\nProblema:\n___\n\n---\n\n## PREGUNTA 7: Production Code (2 puntos)\n\nAudita este código y lista TODOS los problemas de producción que encuentres.\n\n```typescript\nexport async function getUser(id: string) {\n  const response = await fetch(`/api/users/${id}`)\n  const data = await response.json() as any\n  return data.user\n}\n\nexport function updateUser(id: string, updates: any) {\n  return fetch(`/api/users/${id}`, {\n    method: 'PATCH',\n    body: JSON.stringify(updates)\n  })\n}\n```\n\nProblemas encontrados:\n1. ___\n2. ___\n3. ___\n(etc.)\n\n---\n\n## PREGUNTA 8: DTOs (1 punto)\n\n¿Por qué es importante usar DTOs separados para requests y responses?\nDa al menos DOS razones.\n\nRazón 1: ___\nRazón 2: ___\n\n---\n\n## PREGUNTA 9: Council Design (1 punto)\n\nDiseña un council de 3 agentes para \"seleccionar el stack de base de datos\npara un nuevo proyecto\".\n\nAgente 1: ___\nAgente 2: ___\nAgente 3: ___\n\n---\n\n## PREGUNTA 10: Build-time Paranoia (1 punto)\n\n¿ significa \"build-time paranoia\" y por qué es importante?\n\nSignificado:\n___\n\nImportancia:\n___\n```\n\n### Respuestas (para auto-verificación)\n\n```markdown\n## RESPUESTAS SUGERIDAS\n\n**Nota: Estas son respuestas modelo. Respuestas equivalentes también cuentan.**\n\n---\n\nPREGUNTA 1 (2 puntos):\n- Significado: La IA genera múltiples opciones y explora caminos, pero los humanos toman la decisión final sobre qué construir. (1 punto)\n- Importancia: La IA es excelente en el \"cómo\" pero terrible en el \"qué\". Sin esta regla, se pierde control sobre la dirección del proyecto. (1 punto)\n\nPREGUNTA 2 (2 puntos):\nPOLÍTICAS STOP:\n- NO agregar features extras (solo lo necesario para autenticación)\n- NO cambiar código no relacionado con auth\n\nPOLÍTICAS TRUTH:\n- SOLO implementar basado en evidencia provista a continuación\n\nPOLÍTICAS SCOPE:\n- INCLUIR: Login y logout funcional\n- EXCLUIR: UI, frontend, tests, documentación\n\nEVIDENCIA:\n- Framework: Next.js 15 con App Router\n- DB: Supabase\n- Tabla: users con [id, email, password_hash]\n\nOUTPUT:\n- Código TypeScript con interfaces\n- Función login(email, password) → returns session token\n- Función logout(token) → void\n\nPREGUNTA 3 (1 punto):\nTarea A: GLM 4.7, porque es 100x más rápido y barato para tareas repetitivas simples.\nTarea B: Claude Opus, porque requiere razonamiento complejo de arquitectura.\n\nPREGUNTA 4 (1 punto):\nCualquiera de estas estrategias es válida:\n- Usar un decision framework con criterios objetivos y puntuar cada propuesta\n- Crear solución híbrida que combine lo mejor de múltiples propuestas\n- Definir constraints (tiempo, costo, stack) y eliminar propuestas que no las cumplen\n\nPREGUNTA 5 (1 punto):\n- Bug de código (0.5 puntos)\n- Primera acción: Agregar validación en código para manejar caso donde data.user es undefined (0.5 puntos)\n\nPREGUNTA 6 (1 punto):\nDate no se serializa correctamente en JSON. Se convierte a string ISO pero en el receiving end no se deserializa de vuelta a Date automáticamente. Puede causar bugs donde se espera un Date pero se recibe string.\n\nPREGUNTA 7 (2 puntos):\nProblemas (cualquiera de estos cuenta, need 2+ for full points):\n1. `as any` sin validación ni confesión\n2. No manejo de errores (qué pasa si fetch falla?)\n3. No validación de respuesta (data.user puede no existir)\n4. `updates: any` sin tipo ni validación\n5. No hay type safety en la función updateUser\n6. Falta manejo de casos edge (404, 500, etc.)\n7. No hay DTOs para request/response\n\nPREGUNTA 8 (1 punto):\nRazones (cualquiera de estas cuenta):\n1. Request y response tienen diferentes campos (password va en request, no en response)\n2. Previne over-posting (usuario no puede enviar campos que no debería)\n3. Permite validación separada para input vs output\n4. Response puede incluir campos calculados que request no tiene\n\nPREGUNTA 9 (1 punto):\nAgente 1: \"SQL Traditionalist\" - defiende bases de datos SQL (PostgreSQL, MySQL)\nAgente 2: \"NoSQL Advocate\" - defiende bases de datos NoSQL (MongoDB, Firebase)\nAgente 3: \"Pragmatist\" - evalúa basado en requisitos específicos del proyecto\n\nPREGUNTA 10 (1 punto):\n- Significado: Filosofía de validar TODO en build time en lugar de runtime (0.5 puntos)\n- Importancia: Es preferible que falle el build que falle en producción; TypeScript y herramientas de build pueden catch errores antes de llegar a usuarios (0.5 puntos)\n```\n\n---\n\n## Después del Examen\n\n### Si Aprobaste (80%+)\n\n```\n🎉 ¡FELICIDADES! 🎉\n\nHas completado el curso \"De Developer a Vibe Coder\".\n\nSiguientes pasos:\n\n1. Recibirás tu badge oficial de \"Fyves Vibe Coder - Nivel 1\"\n2. Tu certificación será añadida a tu perfil de equipo\n3. Tendrás acceso a repos sensitive (si aplica)\n4. Puedes empezar a mentorear vibe coders junior\n\nPróximo nivel:\n- \"Vibe Coder - Nivel 2\" (Avanzado)\n  - Multi-system orchestration\n  - Production debugging avanzado\n  - Architecture patterns para IA-augmented teams\n```\n\n### Si No Aprobaste (<80%)\n\n```\n💪 NO TE RINDAS 💪\n\nLa certificación es desafiante intencionalmente.\n\nSiguientes pasos:\n\n1. Revisa los módulos donde fallaste\n2. Reintenta el examen en 7 días\n3. Puedes tomar el examen hasta 3 veces\n\nRecursos:\n- Revisa los checkpoints de cada módulo\n- Los ejercicios prácticos son la mejor preparación\n- Pide mentoría si estás atascado\n```\n\n---\n\n## Checklist Final de Certificación\n\nAntes de recibir tu badge:\n\n- [ ] Completé todos los 8 módulos\n- [ ] Completé todos los ejercicios de cada módulo\n- [ ] Aprobé todos los checkpoints\n- [ ] Aprobé el examen final con 80% o más\n- [ ] Entiendo y comprometo a seguir las reglas de Fyves:\n  - [ ] \"IA explora, humanos deciden\"\n  - [ ] Código antes de prompts\n  - [ ] No `as any` sin confesión\n  - [ ] DTOs para fronteras de sistema\n  - [ ] Build-time paranoia\n\n---\n\n## Palabras Finales\n\n```\n┌────────────────────────────────────────────────────────────┐\n│                                                            │\n│     \"Vibe coding no es sobre dejar que la IA haga todo.   │\n│      Es sobre convertirte en un director de orquesta      │\n│      que guía a múltiples músicos (agentes) para          │\n│      crear una sinfonía de código.\"                       │\n│                                                            │\n│             - Filosofía de Fyves Vibe Coding               │\n│                                                            │\n└────────────────────────────────────────────────────────────┘\n\nHas aprendido:\n\n✅ Cómo orquestar IA en lugar de solo \"usarla\"\n✅ Cuándo usar cada modelo para máxima eficiencia\n✅ Cómo escribir prompts que la IA no pueda malinterpretar\n✅ Cómo diseñar councils de agentes para resolver problemas complejos\n✅ Cómo distinguir bugs de código, infraestructura, y configuración\n✅ Cómo escribir código production-ready que no falla\n✅ Cómo auditar código con disciplina y reportar solo hechos\n\nPero lo más importante:\n\n🧠 AHORA PIENSAS COMO UN VIBE CODER\n\nNo eres un developer que \"usa IA\".\nEres un vibe coder que ORQUESTA IA.\n\nBienvenido al siguiente nivel de desarrollo de software. 🚀\n\n---\n\n¿Listo para aplicar todo esto en projects reales?\n\nTu primer assignment post-certificación:\n- Elegir UN project real (tuyo o de equipo)\n- Aplicar TODAS las técnicas aprendidas\n- Documentar el proceso\n- Compartir learnings con el equipo\n\n¡Buena suerte, Vibe Coder! 🏆\n```\n\n---\n\n## Resumen: Certificación\n\n| Concepto Clave | Tu Logro |\n|----------------|----------|\n| **100% completado** | Todos los módulos y ejercicios terminados |\n| **Checkpoints aprobados** | Entendimiento validado de cada concepto |\n| **Examen aprobado** | Competencia demostrada en vibe coding |\n| **Badge otorgado** | \"Fyves Vibe Coder - Nivel 1\" |\n| **Acceso habilitado** | Repos sensitive y deployment permissions |\n\n**Checkpoint FINAL**: ¿Estás listo para aplicar vibe coding en production?\n\nLa respuesta debería ser un rotundo **SÍ**. 🎯",
      "content_url": null,
      "sort_order": 8,
      "duration_minutes": 10
    }
  ]
}
